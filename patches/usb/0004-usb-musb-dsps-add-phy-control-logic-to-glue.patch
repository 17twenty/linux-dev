From 4ebf475bc25f1a07be6b959cf804ec60e22f33fa Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Thu, 5 Jul 2012 14:06:42 +0530
Subject: [PATCH 04/17] usb: musb: dsps: add phy control logic to glue

AM335x uses NOP transceiver driver and need to enable builtin PHY
by writing into usb_ctrl register available in system control
module register space. This is being added at musb glue driver
layer untill a separate system control module driver is available.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
---
 arch/arm/mach-omap2/board-ti8168evm.c   |    1 -
 arch/arm/mach-omap2/omap_phy_internal.c |   35 -------------
 arch/arm/plat-omap/include/plat/usb.h   |    5 +-
 drivers/usb/musb/musb_dsps.c            |   87 +++++++++++++++++++++++++------
 4 files changed, 73 insertions(+), 55 deletions(-)

diff --git a/arch/arm/mach-omap2/board-ti8168evm.c b/arch/arm/mach-omap2/board-ti8168evm.c
index d4c8392..0c7c098 100644
--- a/arch/arm/mach-omap2/board-ti8168evm.c
+++ b/arch/arm/mach-omap2/board-ti8168evm.c
@@ -26,7 +26,6 @@
 #include <plat/usb.h>
 
 static struct omap_musb_board_data musb_board_data = {
-	.set_phy_power	= ti81xx_musb_phy_power,
 	.interface_type	= MUSB_INTERFACE_ULPI,
 	.mode           = MUSB_OTG,
 	.power		= 500,
diff --git a/arch/arm/mach-omap2/omap_phy_internal.c b/arch/arm/mach-omap2/omap_phy_internal.c
index d52651a..d80bb16 100644
--- a/arch/arm/mach-omap2/omap_phy_internal.c
+++ b/arch/arm/mach-omap2/omap_phy_internal.c
@@ -254,38 +254,3 @@ void am35x_set_mode(u8 musb_mode)
 
 	omap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);
 }
-
-void ti81xx_musb_phy_power(u8 on)
-{
-	void __iomem *scm_base = NULL;
-	u32 usbphycfg;
-
-	scm_base = ioremap(TI81XX_SCM_BASE, SZ_2K);
-	if (!scm_base) {
-		pr_err("system control module ioremap failed\n");
-		return;
-	}
-
-	usbphycfg = __raw_readl(scm_base + USBCTRL0);
-
-	if (on) {
-		if (cpu_is_ti816x()) {
-			usbphycfg |= TI816X_USBPHY0_NORMAL_MODE;
-			usbphycfg &= ~TI816X_USBPHY_REFCLK_OSC;
-		} else if (cpu_is_ti814x()) {
-			usbphycfg &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN
-				| USBPHY_DPINPUT | USBPHY_DMINPUT);
-			usbphycfg |= (USBPHY_OTGVDET_EN | USBPHY_OTGSESSEND_EN
-				| USBPHY_DPOPBUFCTL | USBPHY_DMOPBUFCTL);
-		}
-	} else {
-		if (cpu_is_ti816x())
-			usbphycfg &= ~TI816X_USBPHY0_NORMAL_MODE;
-		else if (cpu_is_ti814x())
-			usbphycfg |= USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN;
-
-	}
-	__raw_writel(usbphycfg, scm_base + USBCTRL0);
-
-	iounmap(scm_base);
-}
diff --git a/arch/arm/plat-omap/include/plat/usb.h b/arch/arm/plat-omap/include/plat/usb.h
index 548a4c8..c2aa4ae 100644
--- a/arch/arm/plat-omap/include/plat/usb.h
+++ b/arch/arm/plat-omap/include/plat/usb.h
@@ -95,7 +95,6 @@ extern void am35x_musb_reset(void);
 extern void am35x_musb_phy_power(u8 on);
 extern void am35x_musb_clear_irq(void);
 extern void am35x_set_mode(u8 musb_mode);
-extern void ti81xx_musb_phy_power(u8 on);
 
 /* AM35x */
 /* USB 2.0 PHY Control */
@@ -120,8 +119,8 @@ extern void ti81xx_musb_phy_power(u8 on);
 #define CONF2_DATPOL		(1 << 1)
 
 /* TI81XX specific definitions */
-#define USBCTRL0	0x620
-#define USBSTAT0	0x624
+#define MUSB_USBSS_REV_816X	0x9
+#define MUSB_USBSS_REV_814X	0xb
 
 /* TI816X PHY controls bits */
 #define TI816X_USBPHY0_NORMAL_MODE	(1 << 0)
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index 494772f..72eda64 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -115,9 +115,46 @@ struct dsps_glue {
 	struct platform_device *musb;	/* child musb pdev */
 	const struct dsps_musb_wrapper *wrp; /* wrapper register offsets */
 	struct timer_list timer;	/* otg_workaround timer */
+	u32 __iomem *usb_ctrl;
+	u8      usbss_rev;
 };
 
 /**
+ * musb_dsps_phy_control - phy on/off
+ * @glue: struct dsps_glue *
+ * @on: flag for phy to be switched on or off
+ *
+ * This is to enable the PHY using usb_ctrl register in system control
+ * module space.
+ *
+ * XXX: This function will be removed once we have a seperate driver for
+ * control module
+ */
+static void musb_dsps_phy_control(struct dsps_glue *glue, u8 on)
+{
+	u32 usbphycfg;
+
+	usbphycfg = __raw_readl(glue->usb_ctrl);
+
+	if (on) {
+		if (glue->usbss_rev == MUSB_USBSS_REV_816X) {
+			usbphycfg |= TI816X_USBPHY0_NORMAL_MODE;
+			usbphycfg &= ~TI816X_USBPHY_REFCLK_OSC;
+		} else if (glue->usbss_rev == MUSB_USBSS_REV_814X) {
+			usbphycfg &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN
+				| USBPHY_DPINPUT | USBPHY_DMINPUT);
+			usbphycfg |= (USBPHY_OTGVDET_EN | USBPHY_OTGSESSEND_EN
+				| USBPHY_DPOPBUFCTL | USBPHY_DMOPBUFCTL);
+		}
+	} else {
+		if (glue->usbss_rev == MUSB_USBSS_REV_816X)
+			usbphycfg &= ~TI816X_USBPHY0_NORMAL_MODE;
+		else if (glue->usbss_rev == MUSB_USBSS_REV_814X)
+			usbphycfg |= USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN;
+	}
+	__raw_writel(usbphycfg, glue->usb_ctrl);
+}
+/**
  * dsps_musb_enable - enable interrupts
  */
 static void dsps_musb_enable(struct musb *musb)
@@ -363,11 +400,9 @@ static irqreturn_t dsps_interrupt(int irq, void *hci)
 static int dsps_musb_init(struct musb *musb)
 {
 	struct device *dev = musb->controller;
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
 	struct platform_device *pdev = to_platform_device(dev->parent);
 	struct dsps_glue *glue = platform_get_drvdata(pdev);
 	const struct dsps_musb_wrapper *wrp = glue->wrp;
-	struct omap_musb_board_data *data = plat->board_data;
 	void __iomem *reg_base = musb->ctrl_base;
 	u32 rev, val;
 	int status;
@@ -395,8 +430,7 @@ static int dsps_musb_init(struct musb *musb)
 	dsps_writel(reg_base, wrp->control, (1 << wrp->reset));
 
 	/* Start the on-chip PHY and its PLL. */
-	if (data->set_phy_power)
-		data->set_phy_power(1);
+	musb_dsps_phy_control(glue, 1);
 
 	musb->isr = dsps_interrupt;
 
@@ -418,8 +452,6 @@ err0:
 static int dsps_musb_exit(struct musb *musb)
 {
 	struct device *dev = musb->controller;
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
-	struct omap_musb_board_data *data = plat->board_data;
 	struct platform_device *pdev = to_platform_device(dev->parent);
 	struct dsps_glue *glue = platform_get_drvdata(pdev);
 
@@ -427,8 +459,7 @@ static int dsps_musb_exit(struct musb *musb)
 		del_timer_sync(&glue->timer);
 
 	/* Shutdown the on-chip PHY and its PLL. */
-	if (data->set_phy_power)
-		data->set_phy_power(0);
+	musb_dsps_phy_control(glue, 0);
 
 	/* NOP driver needs change if supporting dual instance */
 	usb_put_phy(musb->xceiv);
@@ -460,6 +491,21 @@ static int __devinit dsps_create_musb_pdev(struct dsps_glue *glue, u8 id)
 	char res_name[10];
 	int ret;
 
+	/* get memory resource for usb control register */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2 * id + 2);
+	if (!res) {
+		dev_err(dev, "%s get mem resource failed\n", res_name);
+		ret = -ENODEV;
+		goto err0;
+	}
+
+	glue->usb_ctrl = devm_request_and_ioremap(&pdev->dev, res);
+	if (glue->usb_ctrl == NULL) {
+		dev_err(dev, "Failed to obtain usb_ctrl%d memory\n", id);
+		ret = -ENODEV;
+		goto err0;
+	}
+
 	/* get memory resource */
 	sprintf(res_name, "musb%d", id);
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);
@@ -538,6 +584,7 @@ static int __devinit dsps_probe(struct platform_device *pdev)
 				(struct dsps_musb_wrapper *)id->driver_data;
 	struct dsps_glue *glue;
 	struct resource *iomem;
+	u32 __iomem *usbss;
 	int ret;
 
 	/* allocate glue */
@@ -556,6 +603,13 @@ static int __devinit dsps_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
+	usbss = devm_request_and_ioremap(&pdev->dev, iomem);
+	if (usbss == NULL) {
+		dev_err(&pdev->dev, "Failed to obtain usbss memory\n");
+		ret = -ENODEV;
+		goto err1;
+	}
+
 	glue->dev = &pdev->dev;
 
 	glue->wrp = kmemdup(wrp, sizeof(*wrp), GFP_KERNEL);
@@ -582,6 +636,9 @@ static int __devinit dsps_probe(struct platform_device *pdev)
 		goto err3;
 	}
 
+	/* read the usbss revision register */
+	glue->usbss_rev = __raw_readl(usbss);
+
 	return 0;
 
 err3:
@@ -612,24 +669,22 @@ static int __devexit dsps_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM_SLEEP
 static int dsps_suspend(struct device *dev)
 {
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
-	struct omap_musb_board_data *data = plat->board_data;
+	struct platform_device *pdev = to_platform_device(dev->parent);
+	struct dsps_glue *glue = platform_get_drvdata(pdev);
 
 	/* Shutdown the on-chip PHY and its PLL. */
-	if (data->set_phy_power)
-		data->set_phy_power(0);
+	musb_dsps_phy_control(glue, 0);
 
 	return 0;
 }
 
 static int dsps_resume(struct device *dev)
 {
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
-	struct omap_musb_board_data *data = plat->board_data;
+	struct platform_device *pdev = to_platform_device(dev->parent);
+	struct dsps_glue *glue = platform_get_drvdata(pdev);
 
 	/* Start the on-chip PHY and its PLL. */
-	if (data->set_phy_power)
-		data->set_phy_power(1);
+	musb_dsps_phy_control(glue, 1);
 
 	return 0;
 }
-- 
1.7.10.4

