From 95964464e30c18619297d996f3e3d967548c1423 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 27 Feb 2012 15:56:47 -0600
Subject: [PATCH] bone: arago angstrom merge

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/mach-omap2/board-am335xevm.c |  623 +++++++++++++++++++++++++++++++--
 arch/arm/mach-omap2/devices.c         |   13 +
 arch/arm/mach-omap2/devices.h         |    1 +
 arch/arm/mach-omap2/mux33xx.c         |   22 +-
 arch/arm/mach-omap2/mux33xx.h         |    4 +
 drivers/input/touchscreen/ti_tscadc.c |  269 ++++++++++++---
 drivers/net/can/dev.c                 |    8 +-
 drivers/net/can/mcp251x.c             |   47 ++-
 drivers/usb/gadget/f_rndis.c          |    4 +-
 drivers/video/Kconfig                 |   11 +
 drivers/video/Makefile                |    1 +
 drivers/video/da8xx-fb.c              |   14 +
 drivers/video/st7735fb.c              |  516 +++++++++++++++++++++++++++
 include/linux/input/ti_tscadc.h       |    5 +
 include/video/st7735fb.h              |   82 +++++
 15 files changed, 1519 insertions(+), 101 deletions(-)
 create mode 100644 drivers/video/st7735fb.c
 create mode 100644 include/video/st7735fb.h

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index 5c761e4..71ed109 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -19,6 +19,7 @@
 #include <linux/i2c/at24.h>
 #include <linux/phy.h>
 #include <linux/gpio.h>
+#include <linux/leds.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 #include <linux/gpio_keys.h>
@@ -35,6 +36,9 @@
 #include <linux/mfd/tps65910.h>
 #include <linux/mfd/tps65217.h>
 #include <linux/pwm_backlight.h>
+#include <linux/pwm/pwm.h>
+#include <linux/w1-gpio.h>
+#include <linux/can/platform/mcp251x.h>
 
 /* LCD controller is similar to DA850 */
 #include <video/da8xx-fb.h>
@@ -130,8 +134,8 @@ static const struct display_panel disp_panel = {
 
 /* LCD backlight platform Data */
 #define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
-#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
-#define AM335X_PWM_PERIOD_NANO_SECONDS        (1000000 * 10)
+#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    50
+#define AM335X_PWM_PERIOD_NANO_SECONDS        (1000000 * 5)
 
 #define PWM_DEVICE_ID   "ecap.0"
 
@@ -168,6 +172,76 @@ struct da8xx_lcdc_platform_data TFC_S9700RTWV35TR_01B_pdata = {
 
 #include "common.h"
 
+static const struct display_panel bbtoys7_panel = {
+	WVGA,
+	16,
+	16,
+	COLOR_ACTIVE,
+};
+
+#define BBTOYS7LCD_PWM_DEVICE_ID   "ehrpwm.1:0"
+
+static struct platform_pwm_backlight_data bbtoys7lcd_backlight_data = {
+	.pwm_id         = BBTOYS7LCD_PWM_DEVICE_ID,
+	.ch             = -1,
+	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
+	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
+	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
+};
+
+static struct lcd_ctrl_config bbtoys7_cfg = {
+	&bbtoys7_panel,
+	.ac_bias		= 255,
+	.ac_bias_intrpt		= 0,
+	.dma_burst_sz		= 16,
+	.bpp			= 16,
+	.fdd			= 0x80,
+	.tft_alt_mode		= 0,
+	.stn_565_mode		= 0,
+	.mono_8bit_mode		= 0,
+	.invert_line_clock	= 1,
+	.invert_frm_clock	= 1,
+	.sync_edge		= 0,
+	.sync_ctrl		= 1,
+	.raster_order		= 0,
+};
+
+struct da8xx_lcdc_platform_data bbtoys7_pdata = {
+	.manu_name		= "ThreeFive",
+	.controller_data	= &bbtoys7_cfg,
+	.type			= "TFC_S9700RTWV35TR_01B",
+};
+
+static const struct display_panel dvi_panel = {
+	WVGA,
+	16,
+	16,
+	COLOR_ACTIVE,
+};
+
+static struct lcd_ctrl_config dvi_cfg = {
+	&dvi_panel,
+	.ac_bias		= 255,
+	.ac_bias_intrpt		= 0,
+	.dma_burst_sz		= 16,
+	.bpp			= 16,
+	.fdd			= 0x80,
+	.tft_alt_mode		= 0,
+	.stn_565_mode		= 0,
+	.mono_8bit_mode		= 0,
+	.invert_line_clock	= 1,
+	.invert_frm_clock	= 1,
+	.sync_edge		= 0,
+	.sync_ctrl		= 1,
+	.raster_order		= 0,
+};
+
+struct da8xx_lcdc_platform_data dvi_pdata = {
+	.manu_name		= "BBToys",
+	.controller_data	= &dvi_cfg,
+	.type			= "1024x768@60",
+};
+
 /* TSc controller */
 #include <linux/input/ti_tscadc.h>
 #include <linux/lis3lv02d.h>
@@ -188,6 +262,11 @@ static struct resource tsc_resources[]  = {
 static struct tsc_data am335x_touchscreen_data  = {
 	.wires  = 4,
 	.x_plate_resistance = 200,
+	.mode = TI_TSCADC_TSCMODE,
+};
+
+static struct tsc_data bone_touchscreen_data  = {
+	.mode = TI_TSCADC_GENMODE,
 };
 
 static struct platform_device tsc_device = {
@@ -200,6 +279,16 @@ static struct platform_device tsc_device = {
 	.resource       = tsc_resources,
 };
 
+static struct platform_device bone_tsc_device = {
+	.name   = "tsc",
+	.id     = -1,
+	.dev    = {
+			.platform_data  = &bone_touchscreen_data,
+	},
+	.num_resources  = ARRAY_SIZE(tsc_resources),
+	.resource       = tsc_resources,
+};
+
 static u8 am335x_iis_serializer_direction1[] = {
 	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,	RX_MODE,
 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
@@ -360,9 +449,34 @@ static struct am335x_evm_eeprom_config config;
 static struct am335x_eeprom_config1 config1;
 static bool daughter_brd_detected;
 
+struct beaglebone_cape_eeprom_config {
+	u32	header;
+	char  format_revision[2];
+	char	name[32];
+	char	version[4];
+	char	manufacturer[16];
+	char	partnumber[16];
+	u16  numpins;
+	char	serial[12];
+	u8	muxdata[170];
+	u16  current_3v3;
+	u16  current_vdd5v;
+	u16  current_sys5v;
+	u16  dc;
+};
+
+static struct beaglebone_cape_eeprom_config cape_config;
+static bool beaglebone_cape_detected;
+
+/* keep track of ADC pin usage */
+static int capecount = 0;
+static bool beaglebone_tsadcpins_free = 1;
+
 #define GP_EVM_REV_IS_1_0		0x1
+#define GP_EVM_REV_IS_1_0A		0x1
 #define GP_EVM_REV_IS_1_1A		0x2
 #define GP_EVM_REV_IS_UNKNOWN		0xFF
+#define GP_EVM_ACTUALLY_BEAGLEBONE  0xBB
 static unsigned int gp_evm_revision = GP_EVM_REV_IS_UNKNOWN;
 
 #define CPLD_REV_1_0A			0x1
@@ -450,11 +564,107 @@ static struct pinmux_config lcdc_pin_mux[] = {
 	{NULL, 0},
 };
 
+/* Module pin mux for Beagleboardtoys DVI cape */
+static struct pinmux_config dvi_pin_mux[] = {
+	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a2.rgmii2_td3", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // USR0 LED
+	{"gpmc_a3.rgmii2_td2", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // USR1 LED
+	{"gpmc_ad7.gpmc_ad7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // DVI PDn
+	{NULL, 0},
+};
+
+/* Module pin mux for Beagleboardtoys 7" LCD cape */
+static struct pinmux_config bbtoys7_pin_mux[] = {
+	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"ecap0_in_pwm0_out.gpio0_7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // AVDD_EN
+	{"gpmc_a2.ehrpwm1A", OMAP_MUX_MODE6 | AM33XX_PIN_OUTPUT}, // Backlight
+	{NULL, 0},
+};
+
+static struct pinmux_config w1_gpio_pin_mux[] = {
+	{"gpmc_ad3.gpio1_3",	OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
 static struct pinmux_config tsc_pin_mux[] = {
 	{"ain0.ain0",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"ain1.ain1",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"ain2.ain2",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"ain3.ain3",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain4.ain4",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain5.ain5",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain6.ain6",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain7.ain7",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"vrefp.vrefp",         OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"vrefn.vrefn",         OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{NULL, 0},
@@ -666,6 +876,15 @@ static struct pinmux_config d_can_ia_pin_mux[] = {
 	{NULL, 0},
 };
 
+static struct pinmux_config tt3201_pin_mux[] = {
+	{"uart1_rxd.d_can1_tx", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT },
+	{"uart1_txd.d_can1_rx", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP },
+	{"mcasp0_fsr.gpio3_19", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP },
+	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP },
+	{"ecap0_in_pwm0_out.spi1_cs1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT_PULLUP },
+	{NULL, 0},
+};
+
 /* Module pin mux for uart2 */
 static struct pinmux_config uart2_pin_mux[] = {
 	{"spi0_sclk.uart2_rxd", OMAP_MUX_MODE1 | AM33XX_SLEWCTRL_SLOW |
@@ -869,6 +1088,118 @@ static struct pinmux_config profibus_pin_mux[] = {
 	{NULL, 0},
 };
 
+#define BEAGLEBONE_W1_GPIO GPIO_TO_PIN(1, 3)
+
+static struct w1_gpio_platform_data bone_w1_gpio_pdata = {
+	.pin		= BEAGLEBONE_W1_GPIO,
+	.is_open_drain	= 0,
+};
+
+static struct platform_device bone_w1_device = {
+	.name			= "w1-gpio",
+	.id			= -1,
+	.dev.platform_data	= &bone_w1_gpio_pdata,
+};
+
+/* LEDS - gpio1_21 -> gpio1_24 */
+
+#define BEAGLEBONE_USR1_LED  GPIO_TO_PIN(1, 21)
+#define BEAGLEBONE_USR2_LED  GPIO_TO_PIN(1, 22)
+#define BEAGLEBONE_USR3_LED  GPIO_TO_PIN(1, 23)
+#define BEAGLEBONE_USR4_LED  GPIO_TO_PIN(1, 24)
+
+static struct gpio_led bone_gpio_leds[] = {
+	{
+		.name			= "beaglebone::usr0",
+		.default_trigger	= "heartbeat",
+		.gpio			= BEAGLEBONE_USR1_LED,
+	},
+	{
+		.name			= "beaglebone::usr1",
+		.default_trigger	= "mmc0",
+		.gpio			= BEAGLEBONE_USR2_LED,
+	},
+	{
+		.name			= "beaglebone::usr2",
+		.gpio			= BEAGLEBONE_USR3_LED,
+	},
+	{
+		.name           = "beaglebone::usr3",
+		.gpio           = BEAGLEBONE_USR4_LED,
+	},
+};
+
+static struct gpio_led_platform_data bone_gpio_led_info = {
+	.leds		= bone_gpio_leds,
+	.num_leds	= ARRAY_SIZE(bone_gpio_leds),
+};
+
+static struct platform_device bone_leds_gpio = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &bone_gpio_led_info,
+	},
+};
+
+
+#define BEAGLEBONEDVI_USR0_LED  GPIO_TO_PIN(1, 18)
+#define BEAGLEBONEDVI_USR1_LED  GPIO_TO_PIN(1, 19)
+
+static struct gpio_led dvi_gpio_leds[] = {
+	{
+		.name			= "beaglebone::usr0",
+		.default_trigger	= "heartbeat",
+		.gpio			= BEAGLEBONE_USR1_LED,
+	},
+	{
+		.name			= "beaglebone::usr1",
+		.default_trigger	= "mmc0",
+		.gpio			= BEAGLEBONE_USR2_LED,
+	},
+	{
+		.name			= "beaglebone::usr2",
+		.gpio			= BEAGLEBONE_USR3_LED,
+	},
+	{
+		.name           = "beaglebone::usr3",
+		.gpio           = BEAGLEBONE_USR4_LED,
+	},
+	{
+		.name			= "dvi::usr0",
+		.default_trigger	= "heartbeat",
+		.gpio			= BEAGLEBONEDVI_USR0_LED,
+	},
+	{
+		.name			= "dvi::usr1",
+		.default_trigger	= "mmc0",
+		.gpio			= BEAGLEBONEDVI_USR1_LED,
+	},
+};
+
+static struct gpio_led_platform_data dvi_gpio_led_info = {
+	.leds		= dvi_gpio_leds,
+	.num_leds	= ARRAY_SIZE(dvi_gpio_leds),
+};
+
+static struct platform_device dvi_leds_gpio = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &dvi_gpio_led_info,
+	},
+};
+
+static struct pinmux_config bone_pin_mux[] = {
+	/* User LED gpios (gpio1_21 to gpio1_24) */
+    {"gpmc_a5.rgmii2_td0", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    {"gpmc_a6.rgmii2_tclk", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    {"gpmc_a7.rgmii2_rclk", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    {"gpmc_a8.rgmii2_rd3", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    /* Grounding gpio1_6 (pin 3 Conn A) signals bone tester to start diag tests */
+    {"gpmc_ad6.gpio1_6", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+};
+
 /* Module pin mux for eCAP0 */
 static struct pinmux_config ecap0_pin_mux[] = {
 	{"ecap0_in_pwm0_out.ecap0_in_pwm0_out",
@@ -876,6 +1207,7 @@ static struct pinmux_config ecap0_pin_mux[] = {
 	{NULL, 0},
 };
 
+static int ehrpwm_backlight_enable;
 static int backlight_enable;
 
 #define AM335XEVM_WLAN_PMENA_GPIO	GPIO_TO_PIN(1, 30)
@@ -945,6 +1277,30 @@ static int __init ecap0_init(void)
 }
 late_initcall(ecap0_init);
 
+static void enable_ehrpwm1(int evm_id, int profile)
+{
+	ehrpwm_backlight_enable = true;
+}
+
+/* Setup pwm-backlight for bbtoys7lcd */
+static struct platform_device bbtoys7lcd_backlight = {
+	.name           = "pwm-backlight",
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &bbtoys7lcd_backlight_data,
+	}
+};
+
+static int __init ehrpwm1_init(void)
+{
+	int status = 0;
+	if (ehrpwm_backlight_enable) {
+		platform_device_register(&bbtoys7lcd_backlight);
+	}
+	return status;
+}
+late_initcall(ehrpwm1_init);
+
 static int __init conf_disp_pll(int rate)
 {
 	struct clk *disp_pll;
@@ -978,6 +1334,47 @@ static void lcdc_init(int evm_id, int profile)
 	return;
 }
 
+#define BEAGLEBONE_LCD_AVDD_EN GPIO_TO_PIN(0, 7)
+
+static void bbtoys7lcd_init(int evm_id, int profile)
+{
+	setup_pin_mux(bbtoys7_pin_mux);
+	gpio_request(BEAGLEBONE_LCD_AVDD_EN, "BONE_LCD_AVDD_EN");
+	gpio_direction_output(BEAGLEBONE_LCD_AVDD_EN, 1);
+
+	// we are being stupid and setting pixclock from here instead of da8xx-fb.c
+	if (conf_disp_pll(300000000)) {
+		pr_info("Failed to set pixclock to 300000000, not attempting to"
+				"register LCD cape\n");
+		return;
+	}
+
+	if (am33xx_register_lcdc(&bbtoys7_pdata))
+		pr_info("Failed to register Beagleboardtoys 7\" LCD cape device\n");
+
+	return;
+}
+
+#define BEAGLEBONEDVI_PDn  GPIO_TO_PIN(1, 7)
+
+static void dvi_init(int evm_id, int profile)
+{
+	setup_pin_mux(dvi_pin_mux);
+	gpio_request(BEAGLEBONEDVI_PDn, "DVI_PDn");
+	gpio_direction_output(BEAGLEBONEDVI_PDn, 1);
+
+	// we are being stupid and setting pixclock from here instead of da8xx-fb.c
+	if (conf_disp_pll(560000000)) {
+		pr_info("Failed to set pixclock to 56000000, not attempting to"
+				"register DVI adapter\n");
+		return;
+	}
+
+	if (am33xx_register_lcdc(&dvi_pdata))
+		pr_info("Failed to register BeagleBoardToys DVI cape\n");
+	return;
+}
+
 static void tsc_init(int evm_id, int profile)
 {
 	int err;
@@ -985,16 +1382,59 @@ static void tsc_init(int evm_id, int profile)
 	if (gp_evm_revision == GP_EVM_REV_IS_1_1A) {
 		am335x_touchscreen_data.analog_input = 1;
 		pr_info("TSC connected to beta GP EVM\n");
-	} else {
+	}
+	if (gp_evm_revision == GP_EVM_REV_IS_1_1A) {
 		am335x_touchscreen_data.analog_input = 0;
 		pr_info("TSC connected to alpha GP EVM\n");
 	}
+	if( gp_evm_revision == GP_EVM_ACTUALLY_BEAGLEBONE) {
+		am335x_touchscreen_data.analog_input = 1;
+		pr_info("TSC connected to BeagleBone\n");
+	}
 	setup_pin_mux(tsc_pin_mux);
 	err = platform_device_register(&tsc_device);
 	if (err)
 		pr_err("failed to register touchscreen device\n");
 }
 
+static void bone_tsc_init(int evm_id, int profile)
+{
+	int err;
+	setup_pin_mux(tsc_pin_mux);
+	err = platform_device_register(&bone_tsc_device);
+	if (err)
+		pr_err("failed to register touchscreen device\n");
+}
+
+
+static void boneleds_init(int evm_id, int profile )
+{
+	int err;
+	setup_pin_mux(bone_pin_mux);
+	err = platform_device_register(&bone_leds_gpio);
+	if (err)
+		pr_err("failed to register BeagleBone LEDS\n");
+}
+
+static void dvileds_init(int evm_id, int profile )
+{
+	int err;
+	err = platform_device_register(&dvi_leds_gpio);
+	if (err)
+		pr_err("failed to register BeagleBone DVI cape LEDS\n");
+}
+
+static void bonew1_gpio_init(int evm_id, int profile )
+{
+	int err;
+	setup_pin_mux(w1_gpio_pin_mux);
+	err = platform_device_register(&bone_w1_device);
+	if (err)
+		pr_err("failed to register w1-gpio\n");
+	else
+		pr_info("w1-gpio connected to P8_6\n");
+}
+
 static void rgmii1_init(int evm_id, int profile)
 {
 	setup_pin_mux(rgmii1_pin_mux);
@@ -1440,18 +1880,150 @@ static void i2c1_init(int evm_id, int profile)
 	return;
 }
 
+static struct mcp251x_platform_data mcp251x_info = {
+	.oscillator_frequency = 16000000,
+};
 
-static struct i2c_board_info am335x_i2c_boardinfo2[] = {
+static struct spi_board_info tt3201_spi_info[] = {
+	{
+		.modalias	= "mcp2515",
+		.max_speed_hz	= 10000000,
+		.bus_num	= 2,
+		.chip_select	= 0,
+		.mode		= SPI_MODE_0,
+		.platform_data	= &mcp251x_info,
+	},
+	{
+		.modalias	= "mcp2515",
+		.max_speed_hz	= 10000000,
+		.bus_num	= 2,
+		.chip_select	= 1,
+		.mode		= SPI_MODE_0,
+		.platform_data	= &mcp251x_info,
+	},
 };
 
-static void i2c2_init(int evm_id, int profile)
+static void tt3201_init(int evm_id, int profile)
 {
-	setup_pin_mux(i2c2_pin_mux);
-	omap_register_i2c_bus(3, 100, am335x_i2c_boardinfo2,
-			ARRAY_SIZE(am335x_i2c_boardinfo2));
+	pr_info("TowerTech TT3201 CAN Cape\n");
+
+	setup_pin_mux(spi1_pin_mux);
+	setup_pin_mux(tt3201_pin_mux);
+
+	tt3201_spi_info[0].irq = gpio_to_irq(GPIO_TO_PIN(3, 19));
+	tt3201_spi_info[1].irq = gpio_to_irq(GPIO_TO_PIN(3, 21));
+
+	spi_register_board_info(tt3201_spi_info,
+		ARRAY_SIZE(tt3201_spi_info));
+
+	am33xx_d_can_init(1);
+}
+static void beaglebone_cape_setup(struct memory_accessor *mem_acc, void *context)
+{
+	capecount++;
+	int ret;
+	char tmp[32];
+	char name[32];
+	char manufacturer[32];
+
+	/* get cape specific data */
+	ret = mem_acc->read(mem_acc, (char *)&cape_config, 0, sizeof(cape_config));
+	if (ret != sizeof(cape_config)) {
+		pr_warning("BeagleBone cape EEPROM: could not read eeprom at address 0x%x\n", capecount + 0x53);
+		if ((capecount > 3) && (beaglebone_tsadcpins_free == 1)) {
+			pr_info("BeagleBone cape: exporting ADC pins to sysfs\n");
+			bone_tsc_init(0,0);
+			beaglebone_tsadcpins_free = 0;
+		}
+		return;
+	}
+
+	if (cape_config.header != AM335X_EEPROM_HEADER) {
+		pr_warning("BeagleBone Cape EEPROM: wrong header 0x%x, expected 0x%x\n",
+			cape_config.header, AM335X_EEPROM_HEADER);
+		goto out;
+	}
+
+	pr_info("BeagleBone cape EEPROM: found eeprom at address 0x%x\n", capecount + 0x53);
+	snprintf(name, sizeof(cape_config.name) + 1, "%s", cape_config.name);
+	snprintf(manufacturer, sizeof(cape_config.manufacturer) + 1, "%s", cape_config.manufacturer);
+	pr_info("BeagleBone cape: %s %s\n", manufacturer, name);
+	snprintf(tmp, sizeof(cape_config.partnumber) + 1, "%s", cape_config.partnumber);
+	pr_info("BeagleBone cape partnumber: %s\n", tmp);
+
+	if (!strncmp("BB-BONE-DVID-01", cape_config.partnumber, 15)) {
+			pr_info("BeagleBone cape: initializing DVI cape\n");
+			dvi_init(0,0);
+	}
+	if (!strncmp("BB-BONE-LCD7-01", cape_config.partnumber, 15)) {
+		pr_info("BeagleBone cape: initializing LCD cape\n");
+		bbtoys7lcd_init(0,0);
+		pr_info("BeagleBone cape: initializing LCD cape touchscreen\n");
+		tsc_init(0,0);
+		pr_info("BeagleBone cape: Registering PWM backlight for LCD cape\n");
+		enable_ehrpwm1(0,0);
+		beaglebone_tsadcpins_free = 0;
+	}
+
+	if (!strncmp("TT3201-001", cape_config.partnumber, 10)) {
+		pr_info("BeagleBone cape: initializing CAN cape\n");
+		tt3201_init(0,0);
+	}
+
+	if ((capecount > 3) && (beaglebone_tsadcpins_free == 1)) {
+		pr_info("BeagleBone cape: exporting ADC pins to sysfs\n");
+		bone_tsc_init(0,0);
+		beaglebone_tsadcpins_free = 0;
+	}
+
 	return;
+out:
+	/*
+	 * If the EEPROM hasn't been programed or an incorrect header
+	 * or board name are read, assume this is an old beaglebone board
+	 * (< Rev A3)
+	 */
+	pr_err("Could not detect BeagleBone cape properly\n");
+	beaglebone_cape_detected = false;
+
+}
+
+static struct at24_platform_data cape_eeprom_info = {
+        .byte_len       = (256*1024) / 8,
+        .page_size      = 64,
+        .flags          = AT24_FLAG_ADDR16,
+        .context        = (void *)NULL,
+        .setup          = beaglebone_cape_setup,
+};
+
+static struct i2c_board_info __initdata cape_i2c_boardinfo[] = {
+        {
+                I2C_BOARD_INFO("24c256", 0x54),
+                .platform_data  = &cape_eeprom_info,
+        },
+        {
+                I2C_BOARD_INFO("24c256", 0x55),
+                .platform_data  = &cape_eeprom_info,
+        },
+        {
+                I2C_BOARD_INFO("24c256", 0x56),
+                .platform_data  = &cape_eeprom_info,
+        },
+        {
+                I2C_BOARD_INFO("24c256", 0x57),
+                .platform_data  = &cape_eeprom_info,
+        },
+};
+
+static void i2c2_init(int evm_id, int profile)
+{
+        setup_pin_mux(i2c2_pin_mux);
+        omap_register_i2c_bus(3, 100, cape_i2c_boardinfo,
+                        ARRAY_SIZE(cape_i2c_boardinfo));
+        return;
 }
 
+
 /* Setup McASP 1 */
 static void mcasp1_init(int evm_id, int profile)
 {
@@ -1805,8 +2377,9 @@ static struct evm_dev_cfg beaglebone_old_dev_cfg[] = {
 	{rmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{boneleds_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
 	{NULL, 0, 0},
 };
 
@@ -1816,8 +2389,10 @@ static struct evm_dev_cfg beaglebone_dev_cfg[] = {
 	{mii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{boneleds_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
+	{bonew1_gpio_init, DEV_ON_BASEBOARD, PROFILE_ALL},
 	{NULL, 0, 0},
 };
 
@@ -1834,6 +2409,7 @@ static void setup_general_purpose_evm(void)
 	pr_info("The board is general purpose EVM in profile %d\n", prof_sel);
 
 	if (!strncmp("1.1A", config.version, 4)) {
+		pr_info("EVM version is %s\n", config.version);
 		gp_evm_revision = GP_EVM_REV_IS_1_1A;
 	} else if (!strncmp("1.0", config.version, 3)) {
 		gp_evm_revision = GP_EVM_REV_IS_1_0;
@@ -1904,6 +2480,7 @@ static void setup_beaglebone_old(void)
 static void setup_beaglebone(void)
 {
 	pr_info("The board is a AM335x Beaglebone.\n");
+	gp_evm_revision = GP_EVM_ACTUALLY_BEAGLEBONE;
 
 	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
 	am335x_mmc[0].gpio_wp = -EINVAL;
@@ -1920,32 +2497,22 @@ static void setup_beaglebone(void)
 
 static void am335x_setup_daughter_board(struct memory_accessor *m, void *c)
 {
+	u8 tmp;
 	int ret;
 
 	/*
-	 * Read from the EEPROM to see the presence
-	 * of daughter board. If present, get daughter board
-	 * specific data.
+	 * try reading a byte from the EEPROM to see if it is
+	 * present. We could read a lot more, but that would
+	 * just slow the boot process and we have all the information
+	 * we need from the EEPROM on the base board anyway.
 	 */
-
-	ret = m->read(m, (char *)&config1, 0, sizeof(config1));
-	if (ret == sizeof(config1)) {
+	ret = m->read(m, &tmp, 0, sizeof(u8));
+	if (ret == sizeof(u8)) {
 		pr_info("Detected a daughter card on AM335x EVM..");
 		daughter_brd_detected = true;
-	}
-	 else {
+	} else {
 		pr_info("No daughter card found\n");
 		daughter_brd_detected = false;
-		return;
-	}
-
-	if (!strncmp("CPLD1.0A", config1.cpld_ver, 8))
-		cpld_version = CPLD_REV_1_0A;
-	else if (!strncmp("CPLD1.1A", config1.cpld_ver, 8))
-		cpld_version = CPLD_REV_1_1A;
-	else {
-		pr_err("Unknown CPLD version found, falling back to 1.0A\n");
-		cpld_version = CPLD_REV_1_0A;
 	}
 }
 
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 1231b8d..3d7f8c1 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1203,6 +1203,19 @@ void register_ehrpwm(int max_freq)
 	platform_device_register(&am335x_epwm2_device);
 }
 
+void register_ehrpwm1(int max_freq)
+{
+	int val;
+
+	val = __raw_readw(AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
+	val |= PWMSS1_TBCLKEN;
+	__raw_writew(val, AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
+	am335x_pwmss_config1.chan_attrib[1].max_freq = max_freq;
+	sema_init(&am335x_pwmss_config1.config_semaphore, 1);
+	am335x_pwmss_config1.version = PWM_VERSION_1;
+	platform_device_register(&am335x_epwm1_device);
+}
+
 static struct resource am335x_ecap0_resurce[] = {
 	{
 		.start = AM33XX_EPWMSS0_BASE ,
diff --git a/arch/arm/mach-omap2/devices.h b/arch/arm/mach-omap2/devices.h
index 0d0e4a4..8f8206b 100644
--- a/arch/arm/mach-omap2/devices.h
+++ b/arch/arm/mach-omap2/devices.h
@@ -18,6 +18,7 @@ int omap3_init_camera(struct isp_platform_data *pdata);
 
 int __init am335x_register_mcasp(struct snd_platform_data *pdata, int ctrl_nr);
 extern void register_ehrpwm(int max_freq);
+extern void register_ehrpwm1(int max_freq);
 extern int __init omap_init_elm(void);
 
 #endif
diff --git a/arch/arm/mach-omap2/mux33xx.c b/arch/arm/mach-omap2/mux33xx.c
index 59e51e0..25dcedb 100644
--- a/arch/arm/mach-omap2/mux33xx.c
+++ b/arch/arm/mach-omap2/mux33xx.c
@@ -85,7 +85,7 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		NULL, NULL, NULL, "gpio1_17"),
 	_AM33XX_MUXENTRY(GPMC_A2, 0,
 		"gpmc_a2", "mii2_txd3", "rgmii2_td3", "mmc2_dat1",
-		NULL, NULL, NULL, "gpio1_18"),
+		NULL, NULL, "ehrpwm1A", "gpio1_18"),
 	_AM33XX_MUXENTRY(GPMC_A3, 0,
 		"gpmc_a3", "mii2_txd2", "rgmii2_td2", "mmc2_dat2",
 		NULL, NULL, NULL, "gpio1_19"),
@@ -312,16 +312,16 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		"uart0_txd", "spi1_cs1", "d_can0_rx", "i2c2_scl",
 		NULL, NULL, NULL, "gpio1_11"),
 	_AM33XX_MUXENTRY(UART1_CTSN, 0,
-		"uart1_ctsn", NULL, NULL, "i2c2_sda",
+		"uart1_ctsn", NULL, "d_can0_tx", "i2c2_sda",
 		"spi1_cs0", NULL, NULL, "gpio0_12"),
 	_AM33XX_MUXENTRY(UART1_RTSN, 0,
-		"uart1_rtsn", NULL, NULL, "i2c2_scl",
+		"uart1_rtsn", NULL, "d_can0_rx", "i2c2_scl",
 		"spi1_cs1", NULL, NULL, "gpio0_13"),
 	_AM33XX_MUXENTRY(UART1_RXD, 0,
-		"uart1_rxd", "mmc1_sdwp", NULL, "i2c1_sda",
+		"uart1_rxd", "mmc1_sdwp", "d_can1_tx", "i2c1_sda",
 		NULL, "pr1_uart0_rxd_mux1", NULL, "gpio0_14"),
 	_AM33XX_MUXENTRY(UART1_TXD, 0,
-		"uart1_txd", "mmc2_sdwp", NULL, "i2c1_scl",
+		"uart1_txd", "mmc2_sdwp", "d_can1_rx", "i2c1_scl",
 		NULL, "pr1_uart0_txd_mux1", NULL, "gpio0_15"),
 	_AM33XX_MUXENTRY(I2C0_SDA, 0,
 		"i2c0_sda", NULL, NULL, NULL,
@@ -584,6 +584,18 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 	_AM33XX_MUXENTRY(AIN3, 0,
 		"ain3", NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN4, 0,
+		"ain4", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN5, 0,
+		"ain5", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN6, 0,
+		"ain6", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN7, 0,
+		"ain7", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
 	_AM33XX_MUXENTRY(VREFP, 0,
 		"vrefp", NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL),
diff --git a/arch/arm/mach-omap2/mux33xx.h b/arch/arm/mach-omap2/mux33xx.h
index 70a3012..348c8e5 100644
--- a/arch/arm/mach-omap2/mux33xx.h
+++ b/arch/arm/mach-omap2/mux33xx.h
@@ -228,6 +228,10 @@
 #define AM33XX_CONTROL_PADCONF_DDR_DQSN1_OFFSET			0x0AFC
 #define AM33XX_CONTROL_PADCONF_DDR_VREF_OFFSET			0x0B00
 #define AM33XX_CONTROL_PADCONF_DDR_VTP_OFFSET			0x0B04
+#define AM33XX_CONTROL_PADCONF_AIN7_OFFSET			0x0B10
+#define AM33XX_CONTROL_PADCONF_AIN6_OFFSET			0x0B14
+#define AM33XX_CONTROL_PADCONF_AIN5_OFFSET			0x0B18
+#define AM33XX_CONTROL_PADCONF_AIN4_OFFSET			0x0B1C
 #define AM33XX_CONTROL_PADCONF_AIN3_OFFSET			0x0B20
 #define AM33XX_CONTROL_PADCONF_AIN2_OFFSET			0x0B24
 #define AM33XX_CONTROL_PADCONF_AIN1_OFFSET			0x0B28
diff --git a/drivers/input/touchscreen/ti_tscadc.c b/drivers/input/touchscreen/ti_tscadc.c
index 49dc007..b6d3d90 100644
--- a/drivers/input/touchscreen/ti_tscadc.c
+++ b/drivers/input/touchscreen/ti_tscadc.c
@@ -26,7 +26,20 @@
 #include <linux/io.h>
 #include <linux/input/ti_tscadc.h>
 #include <linux/delay.h>
-
+#include <linux/device.h>
+
+size_t do_adc_sample(struct kobject *, struct attribute *, char *);
+static DEVICE_ATTR(ain1, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain2, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain3, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain4, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain5, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain6, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain7, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain8, S_IRUGO, do_adc_sample, NULL);
+
+/* Memory mapped registers here have incorrect offsets!
+ * Correct after referring TRM */
 #define TSCADC_REG_IRQEOI		0x020
 #define TSCADC_REG_RAWIRQSTATUS		0x024
 #define TSCADC_REG_IRQSTATUS		0x028
@@ -54,12 +67,18 @@
 
 /*	Register Bitfields	*/
 #define TSCADC_IRQWKUP_ENB		BIT(0)
-#define TSCADC_STPENB_STEPENB		0x7FFF
+#define TSCADC_STPENB_STEPENB_TOUCHSCREEN	0x7FFF
+#define TSCADC_STPENB_STEPENB_GENERAL		0x0400
 #define TSCADC_IRQENB_FIFO0THRES	BIT(2)
+#define TSCADC_IRQENB_FIFO0OVERRUN	BIT(3)
 #define TSCADC_IRQENB_FIFO1THRES	BIT(5)
+#define TSCADC_IRQENB_EOS		BIT(1)
 #define TSCADC_IRQENB_PENUP		BIT(9)
 #define TSCADC_STEPCONFIG_MODE_HWSYNC	0x2
+#define TSCADC_STEPCONFIG_MODE_SWCONT		0x1
+#define TSCADC_STEPCONFIG_MODE_SWONESHOT	0x0
 #define TSCADC_STEPCONFIG_2SAMPLES_AVG	(1 << 4)
+#define TSCADC_STEPCONFIG_NO_AVG	0
 #define TSCADC_STEPCONFIG_XPP		BIT(5)
 #define TSCADC_STEPCONFIG_XNN		BIT(6)
 #define TSCADC_STEPCONFIG_YPP		BIT(7)
@@ -105,6 +124,7 @@ struct tscadc {
 	int			analog_input;
 	int			x_plate_resistance;
 	struct clk		*tsc_ick;
+	int mode;
 	int			irq;
 	void __iomem		*tsc_base;
 };
@@ -120,6 +140,88 @@ static void tscadc_writel(struct tscadc *tsc, unsigned int reg,
 	writel(val, tsc->tsc_base + reg);
 }
 
+/* Configure ADC to sample on channel (1-8) */
+
+static void tsc_adc_step_config(struct tscadc *ts_dev, int channel)
+{
+	unsigned int	stepconfig = 0, delay = 0, chargeconfig = 0;
+
+	/*
+	 * Step Configuration
+	 * software-enabled continous mode
+	 * 2 sample averaging
+	 * sample channel 1 (SEL_INP mux bits = 0)
+	 */
+	stepconfig = TSCADC_STEPCONFIG_MODE_SWONESHOT |
+		TSCADC_STEPCONFIG_2SAMPLES_AVG |
+		((channel-1) << 19);
+
+	delay = TSCADC_STEPCONFIG_SAMPLEDLY | TSCADC_STEPCONFIG_OPENDLY;
+
+	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(10), stepconfig);
+	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(10), delay);
+
+	/* Get the ball rolling, this will trigger the FSM to step through
+	 * as soon as TSC_ADC_SS is turned on */
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_GENERAL);
+}
+
+static irqreturn_t tsc_adc_interrupt(int irq, void *dev)
+{
+	struct tscadc		*ts_dev = (struct tscadc *)dev;
+	struct input_dev	*input_dev = ts_dev->input;
+	unsigned int		status, irqclr = 0;
+	int			i;
+	int			fsm = 0, fifo0count = 0, fifo1count = 0;
+	unsigned int		read_sample = 0, ready1 = 0;
+	unsigned int		prev_val_x = ~0, prev_val_y = ~0;
+	unsigned int		prev_diff_x = ~0, prev_diff_y = ~0;
+	unsigned int		cur_diff_x = 0, cur_diff_y = 0;
+	unsigned int		val_x = 0, val_y = 0, diffx = 0, diffy = 0;
+
+	status = tscadc_readl(ts_dev, TSCADC_REG_IRQSTATUS);
+
+	// printk("interrupt! status=%x\n", status);
+	// if (status & TSCADC_IRQENB_EOS) {
+	// 	irqclr |= TSCADC_IRQENB_EOS;
+	// }
+
+	if (status & TSCADC_IRQENB_FIFO0THRES) {
+		fifo1count = tscadc_readl(ts_dev, TSCADC_REG_FIFO0CNT);
+		// printk("fifo 0 count = %d\n", fifo1count);
+
+		for (i = 0; i < fifo1count; i++) {
+			read_sample = tscadc_readl(ts_dev, TSCADC_REG_FIFO0);
+			printk("sample: %d: %x\n", i, read_sample);
+		}
+		irqclr |= TSCADC_IRQENB_FIFO0THRES;
+	}
+
+
+	if (status & TSCADC_IRQENB_FIFO1THRES) {
+		fifo1count = tscadc_readl(ts_dev, TSCADC_REG_FIFO1CNT);
+
+		for (i = 0; i < fifo1count; i++) {
+			read_sample = tscadc_readl(ts_dev, TSCADC_REG_FIFO1);
+			// read_sample = read_sample & 0xfff;
+			printk("sample: %d: %d\n", i, read_sample);
+			panic("sample read from fifo1!");
+		}
+		irqclr |= TSCADC_IRQENB_FIFO1THRES;
+	}
+
+	// mdelay(500);
+
+	tscadc_writel(ts_dev, TSCADC_REG_IRQSTATUS, irqclr);
+
+	/* check pending interrupts */
+	tscadc_writel(ts_dev, TSCADC_REG_IRQEOI, 0x0);
+
+	/* Turn on Step 1 again */
+	// tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_GENERAL);
+	return IRQ_HANDLED;
+}
+
 static void tsc_step_config(struct tscadc *ts_dev)
 {
 	unsigned int	stepconfigx = 0, stepconfigy = 0;
@@ -224,7 +326,7 @@ static void tsc_step_config(struct tscadc *ts_dev)
 	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG14, stepconfigz2);
 	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY14, delay);
 
-	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_TOUCHSCREEN);
 }
 
 static void tsc_idle_config(struct tscadc *ts_config)
@@ -242,7 +344,7 @@ static void tsc_idle_config(struct tscadc *ts_config)
 	tscadc_writel(ts_config, TSCADC_REG_IDLECONFIG, idleconfig);
 }
 
-static irqreturn_t tscadc_interrupt(int irq, void *dev)
+static irqreturn_t tsc_interrupt(int irq, void *dev)
 {
 	struct tscadc		*ts_dev = (struct tscadc *)dev;
 	struct input_dev	*input_dev = ts_dev->input;
@@ -362,7 +464,7 @@ static irqreturn_t tscadc_interrupt(int irq, void *dev)
 	/* check pending interrupts */
 	tscadc_writel(ts_dev, TSCADC_REG_IRQEOI, 0x0);
 
-	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_TOUCHSCREEN);
 	return IRQ_HANDLED;
 }
 
@@ -370,10 +472,50 @@ static irqreturn_t tscadc_interrupt(int irq, void *dev)
 * The functions for inserting/removing driver as a module.
 */
 
+size_t do_adc_sample(struct kobject *kobj, struct attribute *attr, char *buf) {
+	struct platform_device *pdev;
+	struct device *dev;
+	struct tscadc *ts_dev;
+	int channel_num;
+	int fifo0count = 0;
+	int read_sample = 0;
+
+	pdev = (struct platform_device *)container_of(kobj, struct device, kobj);
+	dev = &pdev->dev;
+
+	ts_dev = dev_get_drvdata(dev);
+
+	if(strncmp(attr->name, "ain", 3)) {
+		printk("Invalid ain num\n");
+		return -EINVAL;
+	}
+
+	channel_num = attr->name[3] - 0x30;
+	if(channel_num > 8 || channel_num < 1) {
+		printk("Invalid channel_num=%d\n", channel_num);
+		return -EINVAL;
+	}
+
+	tsc_adc_step_config(ts_dev, channel_num);
+
+	do {
+		fifo0count = tscadc_readl(ts_dev, TSCADC_REG_FIFO0CNT);
+	}
+	while (!fifo0count);
+
+	while (fifo0count--) {
+			read_sample = tscadc_readl(ts_dev, TSCADC_REG_FIFO0) & 0xfff;
+			// printk("polling sample: %d: %x\n", fifo0count, read_sample);
+	}
+	sprintf(buf, "%d", read_sample);
+
+	return strlen(attr->name);
+}
+
 static	int __devinit tscadc_probe(struct platform_device *pdev)
 {
 	struct tscadc			*ts_dev;
-	struct input_dev		*input_dev;
+	struct input_dev		*input_dev = NULL;
 	int				err;
 	int				clk_value;
 	int				clock_rate, irqenable, ctrl;
@@ -381,6 +523,18 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 	struct resource			*res;
 	struct clk			*clk;
 
+	printk("dev addr = %p\n", &pdev->dev);
+	printk("pdev addr = %p\n", pdev);
+
+	device_create_file(&pdev->dev, &dev_attr_ain1);
+	device_create_file(&pdev->dev, &dev_attr_ain2);
+	device_create_file(&pdev->dev, &dev_attr_ain3);
+	device_create_file(&pdev->dev, &dev_attr_ain4);
+	device_create_file(&pdev->dev, &dev_attr_ain5);
+	device_create_file(&pdev->dev, &dev_attr_ain6);
+	device_create_file(&pdev->dev, &dev_attr_ain7);
+	device_create_file(&pdev->dev, &dev_attr_ain8);
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "no memory resource defined.\n");
@@ -400,13 +554,15 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		dev_err(&pdev->dev, "failed to allocate input device.\n");
-		err = -ENOMEM;
-		goto err_free_mem;
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		input_dev = input_allocate_device();
+		if (!input_dev) {
+			dev_err(&pdev->dev, "failed to allocate input device.\n");
+			err = -ENOMEM;
+			goto err_free_mem;
+		}
+		ts_dev->input = input_dev;
 	}
-	ts_dev->input = input_dev;
 
 	res =  request_mem_region(res->start, resource_size(res), pdev->name);
 	if (!res) {
@@ -422,8 +578,15 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 		goto err_release_mem;
 	}
 
-	err = request_irq(ts_dev->irq, tscadc_interrupt, IRQF_DISABLED,
-				pdev->dev.driver->name, ts_dev);
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		err = request_irq(ts_dev->irq, tsc_interrupt, IRQF_DISABLED,
+					pdev->dev.driver->name, ts_dev);
+	}
+	else {
+		err = request_irq(ts_dev->irq, tsc_adc_interrupt, IRQF_DISABLED,
+					pdev->dev.driver->name, ts_dev);
+	}
+
 	if (err) {
 		dev_err(&pdev->dev, "failed to allocate irq.\n");
 		goto err_unmap_regs;
@@ -459,57 +622,59 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 	ts_dev->wires = pdata->wires;
 	ts_dev->analog_input = pdata->analog_input;
 	ts_dev->x_plate_resistance = pdata->x_plate_resistance;
+	ts_dev->mode = pdata->mode;
 
-	/* Set the control register bits */
+	/* Set the control register bits - 12.5.44 TRM */
 	ctrl = TSCADC_CNTRLREG_STEPCONFIGWRT |
-			TSCADC_CNTRLREG_TSCENB |
-			TSCADC_CNTRLREG_STEPID;
-	switch (ts_dev->wires) {
-	case 4:
-		ctrl |= TSCADC_CNTRLREG_4WIRE;
-		break;
-	case 5:
-		ctrl |= TSCADC_CNTRLREG_5WIRE;
-		break;
-	case 8:
-		ctrl |= TSCADC_CNTRLREG_8WIRE;
-		break;
+				TSCADC_CNTRLREG_STEPID;
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		ctrl |= TSCADC_CNTRLREG_TSCENB;
+		switch (ts_dev->wires) {
+			case 4:
+				ctrl |= TSCADC_CNTRLREG_4WIRE;
+				break;
+			case 5:
+				ctrl |= TSCADC_CNTRLREG_5WIRE;
+				break;
+			case 8:
+				ctrl |= TSCADC_CNTRLREG_8WIRE;
+				break;
+		}
 	}
 	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
 
-	/* Set register bits for Idel Config Mode */
-	tsc_idle_config(ts_dev);
-
-	/* IRQ Enable */
-	irqenable = TSCADC_IRQENB_FIFO1THRES;
+	/* Touch screen / ADC configuration */
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		tsc_idle_config(ts_dev);
+		tsc_step_config(ts_dev);
+		tscadc_writel(ts_dev, TSCADC_REG_FIFO1THR, 6);
+		irqenable = TSCADC_IRQENB_FIFO1THRES;
+		/* Touch screen also needs an input_dev */
+		input_dev->name = "ti-tsc-adcc";
+		input_dev->dev.parent = &pdev->dev;
+		input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+		input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+		input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
+		input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
+		/* register to the input system */
+		err = input_register_device(input_dev);
+		if (err)
+			goto err_fail;
+	}
+	else {
+		tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR, 0);
+		irqenable = 0; // TSCADC_IRQENB_FIFO0THRES;
+	}
 	tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE, irqenable);
 
-	tsc_step_config(ts_dev);
-
-	tscadc_writel(ts_dev, TSCADC_REG_FIFO1THR, 6);
-
 	ctrl |= TSCADC_CNTRLREG_TSCSSENB;
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
-
-	input_dev->name = "ti-tsc-adcc";
-	input_dev->dev.parent = &pdev->dev;
-
-	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-
-	input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
-	input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
-	input_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);
-
-	/* register to the input system */
-	err = input_register_device(input_dev);
-	if (err)
-		goto err_fail;
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);	/* Turn on TSC_ADC */
 
 	platform_set_drvdata(pdev, ts_dev);
 	return 0;
 
 err_fail:
+	printk(KERN_ERR "Fatal error, shutting down TSC_ADC\n");
 	clk_disable(ts_dev->tsc_ick);
 	clk_put(ts_dev->tsc_ick);
 err_free_irq:
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index 25695bd..bc1e87e 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -392,7 +392,7 @@ void can_restart(unsigned long data)
 	stats->rx_bytes += cf->can_dlc;
 
 restart:
-	dev_dbg(dev->dev.parent, "restarted\n");
+	netdev_dbg(dev, "restarted\n");
 	priv->can_stats.restarts++;
 
 	/* Now restart the device */
@@ -400,7 +400,7 @@ restart:
 
 	netif_carrier_on(dev);
 	if (err)
-		dev_err(dev->dev.parent, "Error %d during restart", err);
+		netdev_err(dev, "error %d during restart", err);
 }
 
 int can_restart_now(struct net_device *dev)
@@ -433,7 +433,7 @@ void can_bus_off(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
 
-	dev_dbg(dev->dev.parent, "bus-off\n");
+	netdev_dbg(dev, "bus-off\n");
 
 	netif_carrier_off(dev);
 	priv->can_stats.bus_off++;
@@ -545,7 +545,7 @@ int open_candev(struct net_device *dev)
 	struct can_priv *priv = netdev_priv(dev);
 
 	if (!priv->bittiming.tq && !priv->bittiming.bitrate) {
-		dev_err(dev->dev.parent, "bit-timing not yet defined\n");
+		netdev_err(dev, "bit-timing not yet defined\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/net/can/mcp251x.c b/drivers/net/can/mcp251x.c
index 330140e..b3e231c 100644
--- a/drivers/net/can/mcp251x.c
+++ b/drivers/net/can/mcp251x.c
@@ -93,8 +93,9 @@
 #  define CANCTRL_REQOP_LOOPBACK    0x40
 #  define CANCTRL_REQOP_SLEEP	    0x20
 #  define CANCTRL_REQOP_NORMAL	    0x00
-#  define CANCTRL_OSM		    0x08
 #  define CANCTRL_ABAT		    0x10
+#  define CANCTRL_OSM		    0x08
+#  define CANCTRL_CLKEN		    0x04
 #define TEC	      0x1c
 #define REC	      0x1d
 #define CNF1	      0x2a
@@ -287,7 +288,7 @@ static void mcp251x_clean(struct net_device *net)
 /*
  * Note about handling of error return of mcp251x_spi_trans: accessing
  * registers via SPI is not really different conceptually than using
- * normal I/O assembler instructions, although it's much more
+ * normal I/O assembly instructions, although it's much more
  * complicated from a practical POV. So it's not advisable to always
  * check the return value of this function. Imagine that every
  * read{b,l}, write{b,l} and friends would be bracketed in "if ( < 0)
@@ -490,7 +491,7 @@ static void mcp251x_hw_rx(struct spi_device *spi, int buf_idx)
 
 static void mcp251x_hw_sleep(struct spi_device *spi)
 {
-	mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);
+//	mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);
 }
 
 static netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,
@@ -547,13 +548,16 @@ static int mcp251x_set_normal_mode(struct spi_device *spi)
 
 	if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {
 		/* Put device into loopback mode */
-		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LOOPBACK);
+		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LOOPBACK | CANCTRL_CLKEN);
 	} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {
 		/* Put device into listen-only mode */
-		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LISTEN_ONLY);
+		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LISTEN_ONLY | CANCTRL_CLKEN);
 	} else {
 		/* Put device into normal mode */
-		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_NORMAL);
+		mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_NORMAL | CANCTRL_CLKEN);
+
+                netdev_info(priv->net, "CANCTRL: 0x%02x\n",
+                  mcp251x_read_reg(spi, CANCTRL));
 
 		/* Wait for the device to enter normal mode */
 		timeout = jiffies + HZ;
@@ -585,11 +589,15 @@ static int mcp251x_do_set_bittiming(struct net_device *net)
 			  (bt->prop_seg - 1));
 	mcp251x_write_bits(spi, CNF3, CNF3_PHSEG2_MASK,
 			   (bt->phase_seg2 - 1));
-	dev_info(&spi->dev, "CNF: 0x%02x 0x%02x 0x%02x\n",
+
+	netdev_info(net, "CNF: 0x%02x 0x%02x 0x%02x\n",
 		 mcp251x_read_reg(spi, CNF1),
 		 mcp251x_read_reg(spi, CNF2),
 		 mcp251x_read_reg(spi, CNF3));
 
+	netdev_info(net, "CANCTRL: 0x%02x\n",
+		 mcp251x_read_reg(spi, CANCTRL));
+
 	return 0;
 }
 
@@ -600,6 +608,7 @@ static int mcp251x_setup(struct net_device *net, struct mcp251x_priv *priv,
 
 	mcp251x_write_reg(spi, RXBCTRL(0),
 			  RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);
+
 	mcp251x_write_reg(spi, RXBCTRL(1),
 			  RXBCTRL_RXM0 | RXBCTRL_RXM1);
 	return 0;
@@ -728,7 +737,9 @@ static void mcp251x_tx_work_handler(struct work_struct *ws)
 	mutex_lock(&priv->mcp_lock);
 	if (priv->tx_skb) {
 		if (priv->can.state == CAN_STATE_BUS_OFF) {
+
 			mcp251x_clean(net);
+
 		} else {
 			frame = (struct can_frame *)priv->tx_skb->data;
 
@@ -827,21 +838,37 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 
 		/* Update can state */
 		if (eflag & EFLG_TXBO) {
+
+		        netdev_err(net, "err: bus off\n");
+
 			new_state = CAN_STATE_BUS_OFF;
 			can_id |= CAN_ERR_BUSOFF;
 		} else if (eflag & EFLG_TXEP) {
+
+		        netdev_err(net, "err: txep\n");
+
 			new_state = CAN_STATE_ERROR_PASSIVE;
 			can_id |= CAN_ERR_CRTL;
 			data1 |= CAN_ERR_CRTL_TX_PASSIVE;
+
 		} else if (eflag & EFLG_RXEP) {
+
+		        netdev_err(net, "err: rxep\n");
+
 			new_state = CAN_STATE_ERROR_PASSIVE;
 			can_id |= CAN_ERR_CRTL;
 			data1 |= CAN_ERR_CRTL_RX_PASSIVE;
 		} else if (eflag & EFLG_TXWAR) {
+
+		        netdev_err(net, "err: txwar\n");
+
 			new_state = CAN_STATE_ERROR_WARNING;
 			can_id |= CAN_ERR_CRTL;
 			data1 |= CAN_ERR_CRTL_TX_WARNING;
 		} else if (eflag & EFLG_RXWAR) {
+
+		        netdev_err(net, "err: rxwar\n");
+
 			new_state = CAN_STATE_ERROR_WARNING;
 			can_id |= CAN_ERR_CRTL;
 			data1 |= CAN_ERR_CRTL_RX_WARNING;
@@ -918,7 +945,7 @@ static int mcp251x_open(struct net_device *net)
 
 	ret = open_candev(net);
 	if (ret) {
-		dev_err(&spi->dev, "unable to set initial baudrate!\n");
+		netdev_err(net, "failed to open can device\n");
 		return ret;
 	}
 
@@ -934,7 +961,7 @@ static int mcp251x_open(struct net_device *net)
 		  pdata->irq_flags ? pdata->irq_flags : IRQF_TRIGGER_FALLING,
 		  DEVICE_NAME, priv);
 	if (ret) {
-		dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
+		netdev_err(net, "failed to acquire irq %d\n", spi->irq);
 		if (pdata->transceiver_enable)
 			pdata->transceiver_enable(0);
 		close_candev(net);
@@ -1071,7 +1098,7 @@ static int __devinit mcp251x_can_probe(struct spi_device *spi)
 
 	ret = register_candev(net);
 	if (!ret) {
-		dev_info(&spi->dev, "probed\n");
+		netdev_info(priv->net, "probed\n");
 		return ret;
 	}
 error_probe:
diff --git a/drivers/usb/gadget/f_rndis.c b/drivers/usb/gadget/f_rndis.c
index 6614490..d2f1b6f 100644
--- a/drivers/usb/gadget/f_rndis.c
+++ b/drivers/usb/gadget/f_rndis.c
@@ -767,11 +767,11 @@ rndis_bind(struct usb_configuration *c, struct usb_function *f)
 
 	rndis_set_param_medium(rndis->config, NDIS_MEDIUM_802_3, 0);
 	rndis_set_host_mac(rndis->config, rndis->ethaddr);
-
+/*
 	if (rndis_set_param_vendor(rndis->config, vendorID,
 				manufacturer))
 		goto fail;
-
+*/
 	/* NOTE:  all that is done without knowing or caring about
 	 * the network link ... which is unavailable to this code
 	 * until we're activated via set_alt().
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index f66bf0e..64754de 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2420,6 +2420,17 @@ config FB_PUV3_UNIGFX
 	  Choose this option if you want to use the Unigfx device as a
 	  framebuffer device. Without the support of PCI & AGP.
 
+config FB_ST7735
+	tristate "ST7735 framebuffer support"
+	depends on FB && SPI
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select FB_DEFERRED_IO
+	help
+	  Framebuffer support for the ST7735 display controller in SPI mode.
+
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 9b9d8ff..c6d9851 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -143,6 +143,7 @@ obj-$(CONFIG_FB_MSM)              += msm/
 obj-$(CONFIG_FB_NUC900)           += nuc900fb.o
 obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
+obj-$(CONFIG_FB_ST7735)		  += st7735fb.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 53141f9..87b0512 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -272,6 +272,20 @@ static struct da8xx_panel known_lcd_panels[] = {
 		.pxl_clk = 30000000,
 		.invert_pxl_clk = 0,
 	},
+	/* 1024 x 768 @ 60 Hz  Reduced blanking VESA CVT 0.79M3-R */
+	[3] = {
+		.name = "1024x768@60",
+		.width = 1024,
+		.height = 768,
+		.hfp = 48,
+		.hbp = 80,
+		.hsw = 32,
+		.vfp = 3,
+		.vbp = 15,
+		.vsw = 4,
+		.pxl_clk = 56000000,
+		.invert_pxl_clk = 0,
+	},
 };
 
 /* Enable the Raster Engine of the LCD Controller */
diff --git a/drivers/video/st7735fb.c b/drivers/video/st7735fb.c
new file mode 100644
index 0000000..32b28af
--- /dev/null
+++ b/drivers/video/st7735fb.c
@@ -0,0 +1,516 @@
+/*
+ * linux/drivers/video/st7735fb.c -- FB driver for ST7735 LCD controller
+ * Layout is based on skeletonfb.c by James Simmons and Geert Uytterhoeven.
+ *
+ * Copyright (C) 2011, Matt Porter
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+
+#include <video/st7735fb.h>
+
+static struct st7735_function st7735_cfg_script[] = {
+	{ ST7735_START, ST7735_START},
+	{ ST7735_CMD, ST7735_SWRESET},
+	{ ST7735_DELAY, 150},
+	{ ST7735_CMD, ST7735_SLPOUT},
+	{ ST7735_DELAY, 500},
+	{ ST7735_CMD, ST7735_FRMCTR1},
+	{ ST7735_DATA, 0x01},
+	{ ST7735_DATA, 0x2c},
+	{ ST7735_DATA, 0x2d},
+	{ ST7735_CMD, ST7735_FRMCTR2},
+	{ ST7735_DATA, 0x01},
+	{ ST7735_DATA, 0x2c},
+	{ ST7735_DATA, 0x2d},
+	{ ST7735_CMD, ST7735_FRMCTR3},
+	{ ST7735_DATA, 0x01},
+	{ ST7735_DATA, 0x2c},
+	{ ST7735_DATA, 0x2d},
+	{ ST7735_DATA, 0x01},
+	{ ST7735_DATA, 0x2c},
+	{ ST7735_DATA, 0x2d},
+	{ ST7735_CMD, ST7735_INVCTR},
+	{ ST7735_DATA, 0x07},
+	{ ST7735_CMD, ST7735_PWCTR1},
+	{ ST7735_DATA, 0xa2},
+	{ ST7735_DATA, 0x02},
+	{ ST7735_DATA, 0x84},
+	{ ST7735_CMD, ST7735_PWCTR2},
+	{ ST7735_DATA, 0xc5},
+	{ ST7735_CMD, ST7735_PWCTR3},
+	{ ST7735_DATA, 0x0a},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_CMD, ST7735_PWCTR4},
+	{ ST7735_DATA, 0x8a},
+	{ ST7735_DATA, 0x2a},
+	{ ST7735_CMD, ST7735_PWCTR5},
+	{ ST7735_DATA, 0x8a},
+	{ ST7735_DATA, 0xee},
+	{ ST7735_CMD, ST7735_VMCTR1},
+	{ ST7735_DATA, 0x0e},
+	{ ST7735_CMD, ST7735_INVOFF},
+	{ ST7735_CMD, ST7735_MADCTL},
+	{ ST7735_DATA, 0xc8},
+	{ ST7735_CMD, ST7735_COLMOD},
+	{ ST7735_DATA, 0x05},
+	{ ST7735_CMD, ST7735_CASET},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x7f},
+	{ ST7735_CMD, ST7735_RASET},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x9f},
+	{ ST7735_CMD, ST7735_GMCTRP1},
+	{ ST7735_DATA, 0x02},
+	{ ST7735_DATA, 0x1c},
+	{ ST7735_DATA, 0x07},
+	{ ST7735_DATA, 0x12},
+	{ ST7735_DATA, 0x37},
+	{ ST7735_DATA, 0x32},
+	{ ST7735_DATA, 0x29},
+	{ ST7735_DATA, 0x2d},
+	{ ST7735_DATA, 0x29},
+	{ ST7735_DATA, 0x25},
+	{ ST7735_DATA, 0x2b},
+	{ ST7735_DATA, 0x39},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x01},
+	{ ST7735_DATA, 0x03},
+	{ ST7735_DATA, 0x10},
+	{ ST7735_CMD, ST7735_GMCTRN1},
+	{ ST7735_DATA, 0x03},
+	{ ST7735_DATA, 0x1d},
+	{ ST7735_DATA, 0x07},
+	{ ST7735_DATA, 0x06},
+	{ ST7735_DATA, 0x2e},
+	{ ST7735_DATA, 0x2c},
+	{ ST7735_DATA, 0x29},
+	{ ST7735_DATA, 0x2d},
+	{ ST7735_DATA, 0x2e},
+	{ ST7735_DATA, 0x2e},
+	{ ST7735_DATA, 0x37},
+	{ ST7735_DATA, 0x3f},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x00},
+	{ ST7735_DATA, 0x02},
+	{ ST7735_DATA, 0x10},
+	{ ST7735_CMD, ST7735_DISPON},
+	{ ST7735_DELAY, 100},
+	{ ST7735_CMD, ST7735_NORON},
+	{ ST7735_DELAY, 10},
+	{ ST7735_END, ST7735_END},
+};
+
+static struct fb_fix_screeninfo st7735fb_fix __devinitdata = {
+	.id =		"ST7735",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_PSEUDOCOLOR,
+	.xpanstep =	0,
+	.ypanstep =	0,
+	.ywrapstep =	0,
+	.line_length =	WIDTH*BPP/8,
+	.accel =	FB_ACCEL_NONE,
+};
+
+static struct fb_var_screeninfo st7735fb_var __devinitdata = {
+	.xres =			WIDTH,
+	.yres =			HEIGHT,
+	.xres_virtual =		WIDTH,
+	.yres_virtual =		HEIGHT,
+	.bits_per_pixel =	BPP,
+	.nonstd	=		1,
+};
+
+static int st7735_write(struct st7735fb_par *par, u8 data)
+{
+	u8 txbuf[2]; /* allocation from stack must go */
+
+	txbuf[0] = data;
+
+	return spi_write(par->spi, &txbuf[0], 1);
+}
+
+static void st7735_write_data(struct st7735fb_par *par, u8 data)
+{
+	int ret = 0;
+
+	/* Set data mode */
+	gpio_set_value(par->dc, 1);
+
+	ret = st7735_write(par, data);
+	if (ret < 0)
+		pr_err("%s: write data %02x failed with status %d\n",
+			par->info->fix.id, data, ret);
+}
+
+static int st7735_write_data_buf(struct st7735fb_par *par,
+					u8 *txbuf, int size)
+{
+	/* Set data mode */
+	gpio_set_value(par->dc, 1);
+
+	/* Write entire buffer */
+	return spi_write(par->spi, txbuf, size);
+}
+
+static void st7735_write_cmd(struct st7735fb_par *par, u8 data)
+{
+	int ret = 0;
+
+	/* Set command mode */
+	gpio_set_value(par->dc, 0);
+
+	ret = st7735_write(par, data);
+	if (ret < 0)
+		pr_err("%s: write command %02x failed with status %d\n",
+			par->info->fix.id, data, ret);
+}
+
+static void st7735_run_cfg_script(struct st7735fb_par *par)
+{
+	int i = 0;
+	int end_script = 0;
+
+	do {
+		switch (st7735_cfg_script[i].cmd)
+		{
+		case ST7735_START:
+			break;
+		case ST7735_CMD:
+			st7735_write_cmd(par,
+				st7735_cfg_script[i].data & 0xff);
+			break;
+		case ST7735_DATA:
+			st7735_write_data(par,
+				st7735_cfg_script[i].data & 0xff);
+			break;
+		case ST7735_DELAY:
+			mdelay(st7735_cfg_script[i].data);
+			break;
+		case ST7735_END:
+			end_script = 1;
+		}
+		i++;
+	} while (!end_script);
+}
+
+static void st7735_set_addr_win(struct st7735fb_par *par,
+				int xs, int ys, int xe, int ye)
+{
+	st7735_write_cmd(par, ST7735_CASET);
+	st7735_write_data(par, 0x00);
+	st7735_write_data(par, xs+2);
+	st7735_write_data(par, 0x00);
+	st7735_write_data(par, xe+2);
+	st7735_write_cmd(par, ST7735_RASET);
+	st7735_write_data(par, 0x00);
+	st7735_write_data(par, ys+1);
+	st7735_write_data(par, 0x00);
+	st7735_write_data(par, ye+1);
+}
+
+static void st7735_reset(struct st7735fb_par *par)
+{
+	/* Reset controller */
+	gpio_set_value(par->rst, 0);
+	udelay(10);
+	gpio_set_value(par->rst, 1);
+	mdelay(120);
+}
+
+static void st7735fb_update_display(struct st7735fb_par *par)
+{
+	int ret = 0;
+	u8 *vmem = par->info->screen_base;
+
+	/*
+		TODO:
+		Allow a subset of pages to be passed in
+		(for deferred I/O).  Check pages against
+		pan display settings to see if they
+		should be updated.
+	*/
+	/* For now, just write the full 40KiB on each update */
+
+	/* Set row/column data window */
+	st7735_set_addr_win(par, 0, 0, WIDTH-1, HEIGHT-1);
+
+	/* Internal RAM write command */
+	st7735_write_cmd(par, ST7735_RAMWR);
+
+	/* Blast framebuffer to ST7735 internal display RAM */
+	ret = st7735_write_data_buf(par, vmem, WIDTH*HEIGHT*BPP/8);
+	if (ret < 0)
+		pr_err("%s: spi_write failed to update display buffer\n",
+			par->info->fix.id);
+}
+
+static void st7735fb_deferred_io(struct fb_info *info,
+				struct list_head *pagelist)
+{
+	st7735fb_update_display(info->par);
+}
+
+static int st7735fb_init_display(struct st7735fb_par *par)
+{
+	/* TODO: Need some error checking on gpios */
+
+        /* Request GPIOs and initialize to default values */
+        gpio_request_one(par->rst, GPIOF_OUT_INIT_HIGH,
+			"ST7735 Reset Pin");
+        gpio_request_one(par->dc, GPIOF_OUT_INIT_LOW,
+			"ST7735 Data/Command Pin");
+
+	st7735_reset(par);
+
+	st7735_run_cfg_script(par);
+
+	return 0;
+}
+
+void st7735fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+	struct st7735fb_par *par = info->par;
+
+	sys_fillrect(info, rect);
+
+	st7735fb_update_display(par);
+}
+
+void st7735fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+	struct st7735fb_par *par = info->par;
+
+	sys_copyarea(info, area);
+
+	st7735fb_update_display(par);
+}
+
+void st7735fb_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	struct st7735fb_par *par = info->par;
+
+	sys_imageblit(info, image);
+
+	st7735fb_update_display(par);
+}
+
+static ssize_t st7735fb_write(struct fb_info *info, const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	struct st7735fb_par *par = info->par;
+	unsigned long p = *ppos;
+	void *dst;
+	int err = 0;
+	unsigned long total_size;
+
+	if (info->state != FBINFO_STATE_RUNNING)
+		return -EPERM;
+
+	total_size = info->fix.smem_len;
+
+	if (p > total_size)
+		return -EFBIG;
+
+	if (count > total_size) {
+		err = -EFBIG;
+		count = total_size;
+	}
+
+	if (count + p > total_size) {
+		if (!err)
+			err = -ENOSPC;
+
+		count = total_size - p;
+	}
+
+	dst = (void __force *) (info->screen_base + p);
+
+	if (copy_from_user(dst, buf, count))
+		err = -EFAULT;
+
+	if  (!err)
+		*ppos += count;
+
+	st7735fb_update_display(par);
+
+	return (err) ? err : count;
+}
+
+static struct fb_ops st7735fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_read	= fb_sys_read,
+	.fb_write	= st7735fb_write,
+	.fb_fillrect	= st7735fb_fillrect,
+	.fb_copyarea	= st7735fb_copyarea,
+	.fb_imageblit	= st7735fb_imageblit,
+};
+
+static struct fb_deferred_io st7735fb_defio = {
+	.delay		= HZ,
+	.deferred_io	= st7735fb_deferred_io,
+};
+
+static int __devinit st7735fb_probe (struct spi_device *spi)
+{
+	int chip = spi_get_device_id(spi)->driver_data;
+	struct st7735fb_platform_data *pdata = spi->dev.platform_data;
+	int vmem_size = WIDTH*HEIGHT*BPP/8;
+	u8 *vmem;
+	struct fb_info *info;
+	struct st7735fb_par *par;
+	int retval = -ENOMEM;
+
+	if (chip != ST7735_DISPLAY_AF_TFT18) {
+		pr_err("%s: only the %s device is supported\n", DRVNAME,
+			to_spi_driver(spi->dev.driver)->id_table->name);
+		return -EINVAL;
+	}
+
+	if (!pdata) {
+		pr_err("%s: platform data required for rst and dc info\n",
+			DRVNAME);
+		return -EINVAL;
+	}
+
+	vmem = vzalloc(vmem_size);
+	if (!vmem)
+		return retval;
+
+	info = framebuffer_alloc(sizeof(struct st7735fb_par), &spi->dev);
+	if (!info)
+		goto fballoc_fail;
+
+	info->screen_base = (u8 __force __iomem *)vmem;
+	info->fbops = &st7735fb_ops;
+	info->fix = st7735fb_fix;
+	info->fix.smem_len = vmem_size;
+	info->var = st7735fb_var;
+	/* Choose any packed pixel format as long as it's RGB565 */
+	info->var.red.offset = 11;
+	info->var.red.length = 5;
+	info->var.green.offset = 5;
+	info->var.green.length = 6;
+	info->var.blue.offset = 0;
+	info->var.blue.length = 5;
+	info->var.transp.offset = 0;
+	info->var.transp.length = 0;
+	info->flags = FBINFO_FLAG_DEFAULT |
+#ifdef __LITTLE_ENDIAN
+			FBINFO_FOREIGN_ENDIAN |
+#endif
+			FBINFO_VIRTFB;
+
+	info->fbdefio = &st7735fb_defio;
+	fb_deferred_io_init(info);
+
+	par = info->par;
+	par->info = info;
+	par->spi = spi;
+	par->rst = pdata->rst_gpio;
+	par->dc = pdata->dc_gpio;
+
+	retval = register_framebuffer(info);
+	if (retval < 0)
+		goto fbreg_fail;
+
+	spi_set_drvdata(spi, info);
+
+	retval = st7735fb_init_display(par);
+	if (retval < 0)
+		goto init_fail;
+
+	printk(KERN_INFO
+		"fb%d: %s frame buffer device,\n\tusing %d KiB of video memory\n",
+		info->node, info->fix.id, vmem_size);
+
+	return 0;
+
+
+	/* TODO: release gpios on fail */
+init_fail:
+	spi_set_drvdata(spi, NULL);
+
+fbreg_fail:
+	framebuffer_release(info);
+
+fballoc_fail:
+	vfree(vmem);
+
+	return retval;
+}
+
+static int __devexit st7735fb_remove(struct spi_device *spi)
+{
+	struct fb_info *info = spi_get_drvdata(spi);
+
+	spi_set_drvdata(spi, NULL);
+
+	if (info) {
+		unregister_framebuffer(info);
+		vfree(info->screen_base);
+		framebuffer_release(info);
+	}
+
+	/* TODO: release gpios */
+
+	return 0;
+}
+
+static const struct spi_device_id st7735fb_ids[] = {
+	{ "adafruit_tft18", ST7735_DISPLAY_AF_TFT18 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(spi, st7735fb_ids);
+
+static struct spi_driver st7735fb_driver = {
+	.driver = {
+		.name   = "st7735fb",
+		.owner  = THIS_MODULE,
+	},
+	.id_table = st7735fb_ids,
+	.probe  = st7735fb_probe,
+	.remove = __devexit_p(st7735fb_remove),
+};
+
+static int __init st7735fb_init(void)
+{
+	return spi_register_driver(&st7735fb_driver);
+}
+
+static void __exit st7735fb_exit(void)
+{
+	spi_unregister_driver(&st7735fb_driver);
+}
+
+/* ------------------------------------------------------------------------- */
+
+module_init(st7735fb_init);
+module_exit(st7735fb_exit);
+
+MODULE_DESCRIPTION("FB driver for ST7735 display controller");
+MODULE_AUTHOR("Matt Porter");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/input/ti_tscadc.h b/include/linux/input/ti_tscadc.h
index 2c547bb..fc239c6 100644
--- a/include/linux/input/ti_tscadc.h
+++ b/include/linux/input/ti_tscadc.h
@@ -13,9 +13,14 @@
  *			0.
  * @x_plate_resistance:	X plate resistance.
  */
+#include <linux/device.h>
+
+#define TI_TSCADC_TSCMODE 0
+#define TI_TSCADC_GENMODE 1
 
 struct tsc_data {
 	int wires;
 	int analog_input;
 	int x_plate_resistance;
+	int mode;
 };
diff --git a/include/video/st7735fb.h b/include/video/st7735fb.h
new file mode 100644
index 0000000..6d3f68b
--- /dev/null
+++ b/include/video/st7735fb.h
@@ -0,0 +1,82 @@
+/*
+ * linux/include/video/st7735fb.h -- FB driver for ST7735 LCD controller
+ *
+ * Copyright (C) 2011, Matt Porter
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#define DRVNAME		"st7735fb"
+#define WIDTH		128
+#define HEIGHT		160
+#define BPP		16
+
+/* Supported display modules */
+#define ST7735_DISPLAY_AF_TFT18		0	/* Adafruit SPI TFT 1.8" */
+
+/* Init script function */
+struct st7735_function {
+	u16 cmd;
+	u16 data;
+};
+
+/* Init script commands */
+enum st7735_cmd {
+	ST7735_START,
+	ST7735_END,
+	ST7735_CMD,
+	ST7735_DATA,
+	ST7735_DELAY
+};
+
+struct st7735fb_par {
+	struct spi_device *spi;
+	struct fb_info *info;
+	int rst;
+	int dc;
+};
+
+struct st7735fb_platform_data {
+	int rst_gpio;
+	int dc_gpio;
+};
+
+/* ST7735 Commands */
+#define ST7735_NOP	0x0
+#define ST7735_SWRESET	0x01
+#define ST7735_RDDID	0x04
+#define ST7735_RDDST	0x09
+#define ST7735_SLPIN	0x10
+#define ST7735_SLPOUT	0x11
+#define ST7735_PTLON	0x12
+#define ST7735_NORON	0x13
+#define ST7735_INVOFF	0x20
+#define ST7735_INVON	0x21
+#define ST7735_DISPOFF	0x28
+#define ST7735_DISPON	0x29
+#define ST7735_CASET	0x2A
+#define ST7735_RASET	0x2B
+#define ST7735_RAMWR	0x2C
+#define ST7735_RAMRD	0x2E
+#define ST7735_COLMOD	0x3A
+#define ST7735_MADCTL	0x36
+#define ST7735_FRMCTR1	0xB1
+#define ST7735_FRMCTR2	0xB2
+#define ST7735_FRMCTR3	0xB3
+#define ST7735_INVCTR	0xB4
+#define ST7735_DISSET5	0xB6
+#define ST7735_PWCTR1	0xC0
+#define ST7735_PWCTR2	0xC1
+#define ST7735_PWCTR3	0xC2
+#define ST7735_PWCTR4	0xC3
+#define ST7735_PWCTR5	0xC4
+#define ST7735_VMCTR1	0xC5
+#define ST7735_RDID1	0xDA
+#define ST7735_RDID2	0xDB
+#define ST7735_RDID3	0xDC
+#define ST7735_RDID4	0xDD
+#define ST7735_GMCTRP1	0xE0
+#define ST7735_GMCTRN1	0xE1
+#define ST7735_PWCTR6	0xFC
-- 
1.7.9.1

