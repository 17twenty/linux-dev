From 3591247ac9fb93d0f936786c1a4e6cc8a88922f1 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Wed, 1 Feb 2012 09:44:28 -0600
Subject: [PATCH] bone: arago angstrom merge

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/mach-omap2/board-am335xevm.c |  514 ++++++++++++++++++++++++++++++++-
 arch/arm/mach-omap2/devices.c         |   13 +
 arch/arm/mach-omap2/devices.h         |    1 +
 arch/arm/mach-omap2/mux33xx.c         |   14 +-
 arch/arm/mach-omap2/mux33xx.h         |    4 +
 drivers/input/touchscreen/ti_tscadc.c |  275 ++++++++++++++----
 drivers/mmc/host/omap_hsmmc.c         |    3 +
 include/linux/input/ti_tscadc.h       |    5 +
 8 files changed, 766 insertions(+), 63 deletions(-)

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index 8aa7e10..0f8cb3a 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -19,6 +19,7 @@
 #include <linux/i2c/at24.h>
 #include <linux/phy.h>
 #include <linux/gpio.h>
+#include <linux/leds.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 #include <linux/gpio_keys.h>
@@ -35,6 +36,7 @@
 #include <linux/mfd/tps65910.h>
 #include <linux/mfd/tps65217.h>
 #include <linux/pwm_backlight.h>
+#include <linux/pwm/pwm.h>
 
 /* LCD controller is similar to DA850 */
 #include <video/da8xx-fb.h>
@@ -129,8 +131,8 @@ static const struct display_panel disp_panel = {
 
 /* LCD backlight platform Data */
 #define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
-#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
-#define AM335X_PWM_PERIOD_NANO_SECONDS        (1000000 * 10)
+#define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    50
+#define AM335X_PWM_PERIOD_NANO_SECONDS        (1000000 * 5)
 
 #define PWM_DEVICE_ID   "ecap.0"
 
@@ -167,6 +169,76 @@ struct da8xx_lcdc_platform_data TFC_S9700RTWV35TR_01B_pdata = {
 
 #include "common.h"
 
+static const struct display_panel bbtoys7_panel = {
+	WVGA,
+	16,
+	16,
+	COLOR_ACTIVE,
+};
+
+#define BBTOYS7LCD_PWM_DEVICE_ID   "ehrpwm.1:0"
+
+static struct platform_pwm_backlight_data bbtoys7lcd_backlight_data = {
+	.pwm_id         = BBTOYS7LCD_PWM_DEVICE_ID,
+	.ch             = -1,
+	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
+	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
+	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
+};
+
+static struct lcd_ctrl_config bbtoys7_cfg = {
+	&bbtoys7_panel,
+	.ac_bias		= 255,
+	.ac_bias_intrpt		= 0,
+	.dma_burst_sz		= 16,
+	.bpp			= 16,
+	.fdd			= 0x80,
+	.tft_alt_mode		= 0,
+	.stn_565_mode		= 0,
+	.mono_8bit_mode		= 0,
+	.invert_line_clock	= 1,
+	.invert_frm_clock	= 1,
+	.sync_edge		= 0,
+	.sync_ctrl		= 1,
+	.raster_order		= 0,
+};
+
+struct da8xx_lcdc_platform_data bbtoys7_pdata = {
+	.manu_name		= "ThreeFive",
+	.controller_data	= &bbtoys7_cfg,
+	.type			= "TFC_S9700RTWV35TR_01B",
+};
+
+static const struct display_panel dvi_panel = {
+	WVGA,
+	16,
+	16,
+	COLOR_ACTIVE,
+};
+
+static struct lcd_ctrl_config dvi_cfg = {
+	&dvi_panel,
+	.ac_bias		= 255,
+	.ac_bias_intrpt		= 0,
+	.dma_burst_sz		= 16,
+	.bpp			= 16,
+	.fdd			= 0x80,
+	.tft_alt_mode		= 0,
+	.stn_565_mode		= 0,
+	.mono_8bit_mode		= 0,
+	.invert_line_clock	= 1,
+	.invert_frm_clock	= 1,
+	.sync_edge		= 0,
+	.sync_ctrl		= 1,
+	.raster_order		= 0,
+};
+
+struct da8xx_lcdc_platform_data dvi_pdata = {
+	.manu_name		= "BBToys",
+	.controller_data	= &dvi_cfg,
+	.type			= "1024x768@60",
+};
+
 /* TSc controller */
 #include <linux/input/ti_tscadc.h>
 #include <linux/lis3lv02d.h>
@@ -187,6 +259,11 @@ static struct resource tsc_resources[]  = {
 static struct tsc_data am335x_touchscreen_data  = {
 	.wires  = 4,
 	.x_plate_resistance = 200,
+	.mode = TI_TSCADC_TSCMODE,
+};
+
+static struct tsc_data bone_touchscreen_data  = {
+	.mode = TI_TSCADC_GENMODE,
 };
 
 static struct platform_device tsc_device = {
@@ -199,6 +276,16 @@ static struct platform_device tsc_device = {
 	.resource       = tsc_resources,
 };
 
+static struct platform_device bone_tsc_device = {
+	.name   = "tsc",
+	.id     = -1,
+	.dev    = {
+			.platform_data  = &bone_touchscreen_data,
+	},
+	.num_resources  = ARRAY_SIZE(tsc_resources),
+	.resource       = tsc_resources,
+};
+
 static u8 am335x_iis_serializer_direction1[] = {
 	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,	RX_MODE,
 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
@@ -320,9 +407,34 @@ struct am335x_evm_eeprom_config {
 static struct am335x_evm_eeprom_config config;
 static bool daughter_brd_detected;
 
+struct beaglebone_cape_eeprom_config {
+	u32	header;
+	char  format_revision[2];
+	char	name[32];
+	char	version[4];
+	char	manufacturer[16];
+	char	partnumber[16];
+	u16  numpins;
+	char	serial[12];
+	u8	muxdata[170];
+	u16  current_3v3;
+	u16  current_vdd5v;
+	u16  current_sys5v;
+	u16  dc;
+};
+
+static struct beaglebone_cape_eeprom_config cape_config;
+static bool beaglebone_cape_detected;
+
+/* keep track of ADC pin usage */
+static int capecount = 0;
+static bool beaglebone_tsadcpins_free = 1;
+
 #define GP_EVM_REV_IS_1_0		0x1
+#define GP_EVM_REV_IS_1_0A		0x1
 #define GP_EVM_REV_IS_1_1A		0x2
 #define GP_EVM_REV_IS_UNKNOWN		0xFF
+#define GP_EVM_ACTUALLY_BEAGLEBONE  0xBB
 static unsigned int gp_evm_revision = GP_EVM_REV_IS_UNKNOWN;
 unsigned int gigabit_enable = 1;
 
@@ -404,11 +516,102 @@ static struct pinmux_config lcdc_pin_mux[] = {
 	{NULL, 0},
 };
 
+/* Module pin mux for Beagleboardtoys DVI cape */
+static struct pinmux_config dvi_pin_mux[] = {
+	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+        | AM33XX_PULL_DISA},
+	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"gpmc_a2.rgmii2_td3", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // USR0 LED
+	{"gpmc_a3.rgmii2_td2", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // USR1 LED
+	{"gpmc_ad7.gpmc_ad7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // DVI PDn
+	{NULL, 0},
+};
+
+/* Module pin mux for Beagleboardtoys 7" LCD cape */
+static struct pinmux_config bbtoys7_pin_mux[] = {
+	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data7.lcd_data7",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data8.lcd_data8",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data9.lcd_data9",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_data15.lcd_data15",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
+		| AM33XX_PULL_DISA},
+	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
+	{"ecap0_in_pwm0_out.gpio0_7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // AVDD_EN
+	{"gpmc_a2.ehrpwm1A", OMAP_MUX_MODE6 | AM33XX_PIN_OUTPUT}, // Backlight
+	{NULL, 0},
+};
+
 static struct pinmux_config tsc_pin_mux[] = {
 	{"ain0.ain0",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"ain1.ain1",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"ain2.ain2",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"ain3.ain3",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain4.ain4",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain5.ain5",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain6.ain6",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
+	{"ain7.ain7",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"vrefp.vrefp",         OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{"vrefn.vrefn",         OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
 	{NULL, 0},
@@ -823,6 +1026,105 @@ static struct pinmux_config profibus_pin_mux[] = {
 	{NULL, 0},
 };
 
+/* LEDS - gpio1_21 -> gpio1_24 */
+
+#define BEAGLEBONE_USR1_LED  GPIO_TO_PIN(1, 21)
+#define BEAGLEBONE_USR2_LED  GPIO_TO_PIN(1, 22)
+#define BEAGLEBONE_USR3_LED  GPIO_TO_PIN(1, 23)
+#define BEAGLEBONE_USR4_LED  GPIO_TO_PIN(1, 24)
+
+static struct gpio_led bone_gpio_leds[] = {
+	{
+		.name			= "beaglebone::usr0",
+		.default_trigger	= "heartbeat",
+		.gpio			= BEAGLEBONE_USR1_LED,
+	},
+	{
+		.name			= "beaglebone::usr1",
+		.default_trigger	= "mmc0",
+		.gpio			= BEAGLEBONE_USR2_LED,
+	},
+	{
+		.name			= "beaglebone::usr2",
+		.gpio			= BEAGLEBONE_USR3_LED,
+	},
+	{
+		.name           = "beaglebone::usr3",
+		.gpio           = BEAGLEBONE_USR4_LED,
+	},
+};
+
+static struct gpio_led_platform_data bone_gpio_led_info = {
+	.leds		= bone_gpio_leds,
+	.num_leds	= ARRAY_SIZE(bone_gpio_leds),
+};
+
+static struct platform_device bone_leds_gpio = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &bone_gpio_led_info,
+	},
+};
+
+
+#define BEAGLEBONEDVI_USR0_LED  GPIO_TO_PIN(1, 18)
+#define BEAGLEBONEDVI_USR1_LED  GPIO_TO_PIN(1, 19)
+
+static struct gpio_led dvi_gpio_leds[] = {
+	{
+		.name			= "beaglebone::usr0",
+		.default_trigger	= "heartbeat",
+		.gpio			= BEAGLEBONE_USR1_LED,
+	},
+	{
+		.name			= "beaglebone::usr1",
+		.default_trigger	= "mmc0",
+		.gpio			= BEAGLEBONE_USR2_LED,
+	},
+	{
+		.name			= "beaglebone::usr2",
+		.gpio			= BEAGLEBONE_USR3_LED,
+	},
+	{
+		.name           = "beaglebone::usr3",
+		.gpio           = BEAGLEBONE_USR4_LED,
+	},
+	{
+		.name			= "dvi::usr0",
+		.default_trigger	= "heartbeat",
+		.gpio			= BEAGLEBONEDVI_USR0_LED,
+	},
+	{
+		.name			= "dvi::usr1",
+		.default_trigger	= "mmc0",
+		.gpio			= BEAGLEBONEDVI_USR1_LED,
+	},
+};
+
+static struct gpio_led_platform_data dvi_gpio_led_info = {
+	.leds		= dvi_gpio_leds,
+	.num_leds	= ARRAY_SIZE(dvi_gpio_leds),
+};
+
+static struct platform_device dvi_leds_gpio = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &dvi_gpio_led_info,
+	},
+};
+
+static struct pinmux_config bone_pin_mux[] = {
+	/* User LED gpios (gpio1_21 to gpio1_24) */
+    {"gpmc_a5.rgmii2_td0", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    {"gpmc_a6.rgmii2_tclk", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    {"gpmc_a7.rgmii2_rclk", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    {"gpmc_a8.rgmii2_rd3", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+    /* Grounding gpio1_6 (pin 3 Conn A) signals bone tester to start diag tests */
+    {"gpmc_ad6.gpio1_6", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+};
+
 /* Module pin mux for eCAP0 */
 static struct pinmux_config ecap0_pin_mux[] = {
 	{"ecap0_in_pwm0_out.ecap0_in_pwm0_out",
@@ -830,6 +1132,7 @@ static struct pinmux_config ecap0_pin_mux[] = {
 	{NULL, 0},
 };
 
+static int ehrpwm_backlight_enable;
 static int backlight_enable;
 
 #define AM335XEVM_WLAN_PMENA_GPIO	GPIO_TO_PIN(1, 30)
@@ -899,6 +1202,30 @@ static int __init ecap0_init(void)
 }
 late_initcall(ecap0_init);
 
+static void enable_ehrpwm1(int evm_id, int profile)
+{
+	ehrpwm_backlight_enable = true;
+}
+
+/* Setup pwm-backlight for bbtoys7lcd */
+static struct platform_device bbtoys7lcd_backlight = {
+	.name           = "pwm-backlight",
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &bbtoys7lcd_backlight_data,
+	}
+};
+
+static int __init ehrpwm1_init(void)
+{
+	int status = 0;
+	if (ehrpwm_backlight_enable) {
+		platform_device_register(&bbtoys7lcd_backlight);
+	}
+	return status;
+}
+late_initcall(ehrpwm1_init);
+
 static int __init conf_disp_pll(int rate)
 {
 	struct clk *disp_pll;
@@ -932,6 +1259,47 @@ static void lcdc_init(int evm_id, int profile)
 	return;
 }
 
+#define BEAGLEBONE_LCD_AVDD_EN GPIO_TO_PIN(0, 7)
+
+static void bbtoys7lcd_init(int evm_id, int profile)
+{
+	setup_pin_mux(bbtoys7_pin_mux);
+	gpio_request(BEAGLEBONE_LCD_AVDD_EN, "BONE_LCD_AVDD_EN");
+	gpio_direction_output(BEAGLEBONE_LCD_AVDD_EN, 1);
+
+	// we are being stupid and setting pixclock from here instead of da8xx-fb.c
+	if (conf_disp_pll(300000000)) {
+		pr_info("Failed to set pixclock to 300000000, not attempting to"
+				"register LCD cape\n");
+		return;
+	}
+	
+	if (am33xx_register_lcdc(&bbtoys7_pdata))
+		pr_info("Failed to register Beagleboardtoys 7\" LCD cape device\n");
+		
+	return;
+}
+
+#define BEAGLEBONEDVI_PDn  GPIO_TO_PIN(1, 7)
+
+static void dvi_init(int evm_id, int profile)
+{
+    setup_pin_mux(dvi_pin_mux);
+	gpio_request(BEAGLEBONEDVI_PDn, "DVI_PDn");
+	gpio_direction_output(BEAGLEBONEDVI_PDn, 1);
+
+	// we are being stupid and setting pixclock from here instead of da8xx-fb.c
+	if (conf_disp_pll(560000000)) {
+		pr_info("Failed to set pixclock to 56000000, not attempting to"
+				"register DVI adapter\n");
+		return;
+	}
+	
+	if (am33xx_register_lcdc(&dvi_pdata))
+		pr_info("Failed to register BeagleBoardToys DVI cape\n");
+	return;
+}
+
 static void tsc_init(int evm_id, int profile)
 {
 	int err;
@@ -939,16 +1307,48 @@ static void tsc_init(int evm_id, int profile)
 	if (gp_evm_revision == GP_EVM_REV_IS_1_1A) {
 		am335x_touchscreen_data.analog_input = 1;
 		pr_info("TSC connected to beta GP EVM\n");
-	} else {
+	}
+	if (gp_evm_revision == GP_EVM_REV_IS_1_1A) {
 		am335x_touchscreen_data.analog_input = 0;
 		pr_info("TSC connected to alpha GP EVM\n");
 	}
+	if( gp_evm_revision == GP_EVM_ACTUALLY_BEAGLEBONE) {
+		am335x_touchscreen_data.analog_input = 1;
+		pr_info("TSC connected to BeagleBone\n");
+	}
 	setup_pin_mux(tsc_pin_mux);
 	err = platform_device_register(&tsc_device);
 	if (err)
 		pr_err("failed to register touchscreen device\n");
 }
 
+static void bone_tsc_init(int evm_id, int profile)
+{
+	int err;
+	setup_pin_mux(tsc_pin_mux);
+	err = platform_device_register(&bone_tsc_device);
+	if (err)
+		pr_err("failed to register touchscreen device\n");
+}
+
+
+static void boneleds_init(int evm_id, int profile )
+{
+	int err;
+	setup_pin_mux(bone_pin_mux);
+	err = platform_device_register(&bone_leds_gpio);
+	if (err)
+		pr_err("failed to register BeagleBone LEDS\n");
+}
+
+static void dvileds_init(int evm_id, int profile )
+{
+	int err;
+	err = platform_device_register(&dvi_leds_gpio);
+	if (err)
+		pr_err("failed to register BeagleBone DVI cape LEDS\n");
+}
+
 static void rgmii1_init(int evm_id, int profile)
 {
 	setup_pin_mux(rgmii1_pin_mux);
@@ -1358,18 +1758,108 @@ static void i2c1_init(int evm_id, int profile)
 	return;
 }
 
+static void beaglebone_cape_setup(struct memory_accessor *mem_acc, void *context)
+{
+	capecount++;
+	int ret;
+	char tmp[32];
+	char name[32];
+	char manufacturer[32];
+
+	/* get cape specific data */
+	ret = mem_acc->read(mem_acc, (char *)&cape_config, 0, sizeof(cape_config));
+	if (ret != sizeof(cape_config)) {
+		pr_warning("BeagleBone cape EEPROM: could not read eeprom at address 0x%x\n", capecount + 0x53);
+		if ((capecount > 3) && (beaglebone_tsadcpins_free == 1)) {
+			pr_info("BeagleBone cape: exporting ADC pins to sysfs\n");
+			bone_tsc_init(0,0);
+			beaglebone_tsadcpins_free = 0;
+		}
+		return;
+	}
 
-static struct i2c_board_info am335x_i2c_boardinfo2[] = {
+	if (cape_config.header != AM335X_EEPROM_HEADER) {
+		pr_warning("BeagleBone Cape EEPROM: wrong header 0x%x, expected 0x%x\n",
+			cape_config.header, AM335X_EEPROM_HEADER);
+		goto out;
+	}
+
+	pr_info("BeagleBone cape EEPROM: found eeprom at address 0x%x\n", capecount + 0x53);
+	snprintf(name, sizeof(cape_config.name) + 1, "%s", cape_config.name);
+	snprintf(manufacturer, sizeof(cape_config.manufacturer) + 1, "%s", cape_config.manufacturer);
+	pr_info("BeagleBone cape: %s %s\n", manufacturer, name);
+	snprintf(tmp, sizeof(cape_config.partnumber) + 1, "%s", cape_config.partnumber);
+	pr_info("BeagleBone cape partnumber: %s\n", tmp);
+
+	if (!strncmp("BB-BONE-DVID-01", cape_config.partnumber, 15)) {
+			pr_info("BeagleBone cape: initializing DVI cape\n");
+			dvi_init(0,0);
+	}
+	if (!strncmp("BB-BONE-LCD7-01", cape_config.partnumber, 15)) {
+		pr_info("BeagleBone cape: initializing LCD cape\n");
+		bbtoys7lcd_init(0,0);
+		pr_info("BeagleBone cape: initializing LCD cape touchscreen\n");
+		tsc_init(0,0);
+		pr_info("BeagleBone cape: Registering PWM backlight for LCD cape\n");
+		enable_ehrpwm1(0,0);
+		beaglebone_tsadcpins_free = 0;
+	}
+	
+	
+	if ((capecount > 3) && (beaglebone_tsadcpins_free == 1)) {
+		pr_info("BeagleBone cape: exporting ADC pins to sysfs\n");
+		bone_tsc_init(0,0);
+		beaglebone_tsadcpins_free = 0;
+	}
+	
+	return;
+out:
+	/*
+	 * If the EEPROM hasn't been programed or an incorrect header
+	 * or board name are read, assume this is an old beaglebone board
+	 * (< Rev A3)
+	 */
+	pr_err("Could not detect BeagleBone cape properly\n");
+	beaglebone_cape_detected = false;
+
+}
+
+static struct at24_platform_data cape_eeprom_info = {
+        .byte_len       = (256*1024) / 8,
+        .page_size      = 64,
+        .flags          = AT24_FLAG_ADDR16,
+        .context        = (void *)NULL,
+        .setup          = beaglebone_cape_setup,
+};
+
+static struct i2c_board_info __initdata cape_i2c_boardinfo[] = {
+        {
+                I2C_BOARD_INFO("24c256", 0x54),
+                .platform_data  = &cape_eeprom_info,
+        },
+        {
+                I2C_BOARD_INFO("24c256", 0x55),
+                .platform_data  = &cape_eeprom_info,
+        },
+        {
+                I2C_BOARD_INFO("24c256", 0x56),
+                .platform_data  = &cape_eeprom_info,
+        },
+        {
+                I2C_BOARD_INFO("24c256", 0x57),
+                .platform_data  = &cape_eeprom_info,
+        },
 };
 
 static void i2c2_init(int evm_id, int profile)
 {
-	setup_pin_mux(i2c2_pin_mux);
-	omap_register_i2c_bus(3, 100, am335x_i2c_boardinfo2,
-			ARRAY_SIZE(am335x_i2c_boardinfo2));
-	return;
+        setup_pin_mux(i2c2_pin_mux);
+        omap_register_i2c_bus(3, 100, cape_i2c_boardinfo,
+                        ARRAY_SIZE(cape_i2c_boardinfo));
+        return;
 }
 
+
 /* Setup McASP 1 */
 static void mcasp1_init(int evm_id, int profile)
 {
@@ -1723,8 +2213,9 @@ static struct evm_dev_cfg beaglebone_old_dev_cfg[] = {
 	{rmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{boneleds_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
 	{NULL, 0, 0},
 };
 
@@ -1734,8 +2225,9 @@ static struct evm_dev_cfg beaglebone_dev_cfg[] = {
 	{mii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
-	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
+	{boneleds_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
 	{NULL, 0, 0},
 };
 
@@ -1752,6 +2244,7 @@ static void setup_general_purpose_evm(void)
 	pr_info("The board is general purpose EVM in profile %d\n", prof_sel);
 
 	if (!strncmp("1.1A", config.version, 4)) {
+		pr_info("EVM version is %s\n", config.version);
 		gp_evm_revision = GP_EVM_REV_IS_1_1A;
 	} else if (!strncmp("1.0", config.version, 3)) {
 		gp_evm_revision = GP_EVM_REV_IS_1_0;
@@ -1822,6 +2315,7 @@ static void setup_beaglebone_old(void)
 static void setup_beaglebone(void)
 {
 	pr_info("The board is a AM335x Beaglebone.\n");
+	gp_evm_revision = GP_EVM_ACTUALLY_BEAGLEBONE;
 
 	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
 	am335x_mmc[0].gpio_wp = -EINVAL;
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 4b137e9..33291ae 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1277,6 +1277,19 @@ void register_ehrpwm(int max_freq)
 	platform_device_register(&am335x_epwm2_device);
 }
 
+void register_ehrpwm1(int max_freq)
+{
+	int val;
+
+	val = __raw_readw(AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
+	val |= PWMSS1_TBCLKEN;
+	__raw_writew(val, AM33XX_CTRL_REGADDR(AM33XX_PWMSS_CTRL));
+	am335x_pwmss_config1.chan_attrib[1].max_freq = max_freq;
+	sema_init(&am335x_pwmss_config1.config_semaphore, 1);
+	am335x_pwmss_config1.version = PWM_VERSION_1;
+	platform_device_register(&am335x_epwm1_device);
+}
+
 static struct resource am335x_ecap0_resurce[] = {
 	{
 		.start = AM33XX_EPWMSS0_BASE ,
diff --git a/arch/arm/mach-omap2/devices.h b/arch/arm/mach-omap2/devices.h
index e086839..5161eb4 100644
--- a/arch/arm/mach-omap2/devices.h
+++ b/arch/arm/mach-omap2/devices.h
@@ -18,5 +18,6 @@ int omap3_init_camera(struct isp_platform_data *pdata);
 
 void __init am335x_register_mcasp1(struct snd_platform_data *pdata);
 extern void register_ehrpwm(int max_freq);
+extern void register_ehrpwm1(int max_freq);
 
 #endif
diff --git a/arch/arm/mach-omap2/mux33xx.c b/arch/arm/mach-omap2/mux33xx.c
index 8df8fa9..fcb81ec 100644
--- a/arch/arm/mach-omap2/mux33xx.c
+++ b/arch/arm/mach-omap2/mux33xx.c
@@ -85,7 +85,7 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		NULL, NULL, NULL, "gpio1_17"),
 	_AM33XX_MUXENTRY(GPMC_A2, 0,
 		"gpmc_a2", "mii2_txd3", "rgmii2_td3", "mmc2_dat1",
-		NULL, NULL, NULL, "gpio1_18"),
+		NULL, NULL, "ehrpwm1A", "gpio1_18"),
 	_AM33XX_MUXENTRY(GPMC_A3, 0,
 		"gpmc_a3", "mii2_txd2", "rgmii2_td2", "mmc2_dat2",
 		NULL, NULL, NULL, "gpio1_19"),
@@ -584,6 +584,18 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 	_AM33XX_MUXENTRY(AIN3, 0,
 		"ain3", NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN4, 0,
+		"ain4", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN5, 0,
+		"ain5", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN6, 0,
+		"ain6", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_AM33XX_MUXENTRY(AIN7, 0,
+		"ain7", NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL),
 	_AM33XX_MUXENTRY(VREFP, 0,
 		"vrefp", NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL),
diff --git a/arch/arm/mach-omap2/mux33xx.h b/arch/arm/mach-omap2/mux33xx.h
index 70a3012..348c8e5 100644
--- a/arch/arm/mach-omap2/mux33xx.h
+++ b/arch/arm/mach-omap2/mux33xx.h
@@ -228,6 +228,10 @@
 #define AM33XX_CONTROL_PADCONF_DDR_DQSN1_OFFSET			0x0AFC
 #define AM33XX_CONTROL_PADCONF_DDR_VREF_OFFSET			0x0B00
 #define AM33XX_CONTROL_PADCONF_DDR_VTP_OFFSET			0x0B04
+#define AM33XX_CONTROL_PADCONF_AIN7_OFFSET			0x0B10
+#define AM33XX_CONTROL_PADCONF_AIN6_OFFSET			0x0B14
+#define AM33XX_CONTROL_PADCONF_AIN5_OFFSET			0x0B18
+#define AM33XX_CONTROL_PADCONF_AIN4_OFFSET			0x0B1C
 #define AM33XX_CONTROL_PADCONF_AIN3_OFFSET			0x0B20
 #define AM33XX_CONTROL_PADCONF_AIN2_OFFSET			0x0B24
 #define AM33XX_CONTROL_PADCONF_AIN1_OFFSET			0x0B28
diff --git a/drivers/input/touchscreen/ti_tscadc.c b/drivers/input/touchscreen/ti_tscadc.c
index e3b5775..07b3787 100644
--- a/drivers/input/touchscreen/ti_tscadc.c
+++ b/drivers/input/touchscreen/ti_tscadc.c
@@ -26,7 +26,20 @@
 #include <linux/io.h>
 #include <linux/input/ti_tscadc.h>
 #include <linux/delay.h>
-
+#include <linux/device.h>
+
+size_t do_adc_sample(struct kobject *, struct attribute *, char *);
+static DEVICE_ATTR(ain1, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain2, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain3, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain4, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain5, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain6, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain7, S_IRUGO, do_adc_sample, NULL);
+static DEVICE_ATTR(ain8, S_IRUGO, do_adc_sample, NULL);
+
+/* Memory mapped registers here have incorrect offsets!
+ * Correct after referring TRM */
 #define TSCADC_REG_IRQEOI		0x020
 #define TSCADC_REG_RAWIRQSTATUS		0x024
 #define TSCADC_REG_IRQSTATUS		0x028
@@ -54,12 +67,18 @@
 
 /*	Register Bitfields	*/
 #define TSCADC_IRQWKUP_ENB		BIT(0)
-#define TSCADC_STPENB_STEPENB		0x7FFF
+#define TSCADC_STPENB_STEPENB_TOUCHSCREEN	0x7FFF
+#define TSCADC_STPENB_STEPENB_GENERAL		0x0400
 #define TSCADC_IRQENB_FIFO0THRES	BIT(2)
+#define TSCADC_IRQENB_FIFO0OVERRUN	BIT(3)
 #define TSCADC_IRQENB_FIFO1THRES	BIT(5)
+#define TSCADC_IRQENB_EOS		BIT(1)
 #define TSCADC_IRQENB_PENUP		BIT(9)
 #define TSCADC_STEPCONFIG_MODE_HWSYNC	0x2
+#define TSCADC_STEPCONFIG_MODE_SWCONT		0x1
+#define TSCADC_STEPCONFIG_MODE_SWONESHOT	0x0
 #define TSCADC_STEPCONFIG_2SAMPLES_AVG	(1 << 4)
+#define TSCADC_STEPCONFIG_NO_AVG	0
 #define TSCADC_STEPCONFIG_XPP		BIT(5)
 #define TSCADC_STEPCONFIG_XNN		BIT(6)
 #define TSCADC_STEPCONFIG_YPP		BIT(7)
@@ -105,6 +124,7 @@ struct tscadc {
 	int			analog_input;
 	int			x_plate_resistance;
 	struct clk		*tsc_ick;
+	int mode;
 	int			irq;
 	void __iomem		*tsc_base;
 };
@@ -120,6 +140,88 @@ static void tscadc_writel(struct tscadc *tsc, unsigned int reg,
 	writel(val, tsc->tsc_base + reg);
 }
 
+/* Configure ADC to sample on channel (1-8) */
+
+static void tsc_adc_step_config(struct tscadc *ts_dev, int channel)
+{
+	unsigned int	stepconfig = 0, delay = 0, chargeconfig = 0;
+
+	/*
+ 	 * Step Configuration
+ 	 * software-enabled continous mode
+ 	 * 2 sample averaging
+ 	 * sample channel 1 (SEL_INP mux bits = 0)
+ 	 */
+	stepconfig = TSCADC_STEPCONFIG_MODE_SWONESHOT |
+		TSCADC_STEPCONFIG_2SAMPLES_AVG |
+		((channel-1) << 19);
+	
+	delay = TSCADC_STEPCONFIG_SAMPLEDLY | TSCADC_STEPCONFIG_OPENDLY;
+
+	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG(10), stepconfig);
+	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY(10), delay);
+	
+	/* Get the ball rolling, this will trigger the FSM to step through
+ 	 * as soon as TSC_ADC_SS is turned on */
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_GENERAL);
+}
+
+static irqreturn_t tsc_adc_interrupt(int irq, void *dev)
+{
+	struct tscadc		*ts_dev = (struct tscadc *)dev;
+	struct input_dev	*input_dev = ts_dev->input;
+	unsigned int		status, irqclr = 0;
+	int			i;
+	int			fsm = 0, fifo0count = 0, fifo1count = 0;
+	unsigned int		read_sample = 0, ready1 = 0;
+	unsigned int		prev_val_x = ~0, prev_val_y = ~0;
+	unsigned int		prev_diff_x = ~0, prev_diff_y = ~0;
+	unsigned int		cur_diff_x = 0, cur_diff_y = 0;
+	unsigned int		val_x = 0, val_y = 0, diffx = 0, diffy = 0;
+
+	status = tscadc_readl(ts_dev, TSCADC_REG_IRQSTATUS);
+
+	// printk("interrupt! status=%x\n", status);
+	// if (status & TSCADC_IRQENB_EOS) {
+	// 	irqclr |= TSCADC_IRQENB_EOS;
+	// }
+
+	if (status & TSCADC_IRQENB_FIFO0THRES) {
+		fifo1count = tscadc_readl(ts_dev, TSCADC_REG_FIFO0CNT);
+		// printk("fifo 0 count = %d\n", fifo1count);
+	
+		for (i = 0; i < fifo1count; i++) {
+			read_sample = tscadc_readl(ts_dev, TSCADC_REG_FIFO0);
+			printk("sample: %d: %x\n", i, read_sample);
+		}
+		irqclr |= TSCADC_IRQENB_FIFO0THRES;
+	}
+
+
+	if (status & TSCADC_IRQENB_FIFO1THRES) {
+		fifo1count = tscadc_readl(ts_dev, TSCADC_REG_FIFO1CNT);
+
+		for (i = 0; i < fifo1count; i++) {
+			read_sample = tscadc_readl(ts_dev, TSCADC_REG_FIFO1);
+			// read_sample = read_sample & 0xfff;
+			printk("sample: %d: %d\n", i, read_sample);
+			panic("sample read from fifo1!");
+		}
+		irqclr |= TSCADC_IRQENB_FIFO1THRES;
+	}
+
+	// mdelay(500);
+
+	tscadc_writel(ts_dev, TSCADC_REG_IRQSTATUS, irqclr);
+
+	/* check pending interrupts */
+	tscadc_writel(ts_dev, TSCADC_REG_IRQEOI, 0x0);
+
+	/* Turn on Step 1 again */
+	// tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_GENERAL);
+	return IRQ_HANDLED;
+}
+
 static void tsc_step_config(struct tscadc *ts_dev)
 {
 	unsigned int	stepconfigx = 0, stepconfigy = 0;
@@ -224,7 +326,7 @@ static void tsc_step_config(struct tscadc *ts_dev)
 	tscadc_writel(ts_dev, TSCADC_REG_STEPCONFIG14, stepconfigz2);
 	tscadc_writel(ts_dev, TSCADC_REG_STEPDELAY14, delay);
 
-	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_TOUCHSCREEN);
 }
 
 static void tsc_idle_config(struct tscadc *ts_config)
@@ -242,7 +344,7 @@ static void tsc_idle_config(struct tscadc *ts_config)
 	tscadc_writel(ts_config, TSCADC_REG_IDLECONFIG, idleconfig);
 }
 
-static irqreturn_t tscadc_interrupt(int irq, void *dev)
+static irqreturn_t tsc_interrupt(int irq, void *dev)
 {
 	struct tscadc		*ts_dev = (struct tscadc *)dev;
 	struct input_dev	*input_dev = ts_dev->input;
@@ -362,7 +464,7 @@ static irqreturn_t tscadc_interrupt(int irq, void *dev)
 	/* check pending interrupts */
 	tscadc_writel(ts_dev, TSCADC_REG_IRQEOI, 0x0);
 
-	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB);
+	tscadc_writel(ts_dev, TSCADC_REG_SE, TSCADC_STPENB_STEPENB_TOUCHSCREEN);
 	return IRQ_HANDLED;
 }
 
@@ -370,10 +472,50 @@ static irqreturn_t tscadc_interrupt(int irq, void *dev)
 * The functions for inserting/removing driver as a module.
 */
 
+size_t do_adc_sample(struct kobject *kobj, struct attribute *attr, char *buf) {
+	struct platform_device *pdev;
+	struct device *dev;
+	struct tscadc *ts_dev;
+	int channel_num;
+	int fifo0count = 0;
+	int read_sample = 0;
+
+	pdev = (struct platform_device *)container_of(kobj, struct device, kobj);
+	dev = &pdev->dev;
+
+	ts_dev = dev_get_drvdata(dev);
+
+	if(strncmp(attr->name, "ain", 3)) {
+		printk("Invalid ain num\n");
+		return -EINVAL;
+	}
+
+	channel_num = attr->name[3] - 0x30;
+	if(channel_num > 8 || channel_num < 1) {
+		printk("Invalid channel_num=%d\n", channel_num);
+		return -EINVAL;
+	}
+
+	tsc_adc_step_config(ts_dev, channel_num);
+
+	do {
+		fifo0count = tscadc_readl(ts_dev, TSCADC_REG_FIFO0CNT);
+	}
+	while (!fifo0count);
+
+	while (fifo0count--) {
+			  read_sample = tscadc_readl(ts_dev, TSCADC_REG_FIFO0) & 0xfff;
+			  // printk("polling sample: %d: %x\n", fifo0count, read_sample);
+	}
+	sprintf(buf, "%d", read_sample);
+
+	return strlen(attr->name);
+}
+
 static	int __devinit tscadc_probe(struct platform_device *pdev)
 {
 	struct tscadc			*ts_dev;
-	struct input_dev		*input_dev;
+	struct input_dev		*input_dev = NULL;
 	int				err;
 	int				clk_value;
 	int				clock_rate, irqenable, ctrl;
@@ -381,6 +523,18 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 	struct resource			*res;
 	struct clk			*clk;
 
+	printk("dev addr = %p\n", &pdev->dev);
+	printk("pdev addr = %p\n", pdev);
+
+	device_create_file(&pdev->dev, &dev_attr_ain1);
+	device_create_file(&pdev->dev, &dev_attr_ain2);
+	device_create_file(&pdev->dev, &dev_attr_ain3);
+	device_create_file(&pdev->dev, &dev_attr_ain4);
+	device_create_file(&pdev->dev, &dev_attr_ain5);
+	device_create_file(&pdev->dev, &dev_attr_ain6);
+	device_create_file(&pdev->dev, &dev_attr_ain7);
+	device_create_file(&pdev->dev, &dev_attr_ain8);
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "no memory resource defined.\n");
@@ -400,13 +554,15 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		dev_err(&pdev->dev, "failed to allocate input device.\n");
-		err = -ENOMEM;
-		goto err_free_mem;
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		input_dev = input_allocate_device();
+		if (!input_dev) {
+			dev_err(&pdev->dev, "failed to allocate input device.\n");
+			err = -ENOMEM;
+			goto err_free_mem;
+		}
+		ts_dev->input = input_dev;
 	}
-	ts_dev->input = input_dev;
 
 	res =  request_mem_region(res->start, resource_size(res), pdev->name);
 	if (!res) {
@@ -422,8 +578,15 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 		goto err_release_mem;
 	}
 
-	err = request_irq(ts_dev->irq, tscadc_interrupt, IRQF_DISABLED,
-				pdev->dev.driver->name, ts_dev);
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		err = request_irq(ts_dev->irq, tsc_interrupt, IRQF_DISABLED,
+					pdev->dev.driver->name, ts_dev);
+	}
+	else {
+		err = request_irq(ts_dev->irq, tsc_adc_interrupt, IRQF_DISABLED,
+					pdev->dev.driver->name, ts_dev);
+	}
+
 	if (err) {
 		dev_err(&pdev->dev, "failed to allocate irq.\n");
 		goto err_unmap_regs;
@@ -443,11 +606,17 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 		goto err_free_irq;
 	}
 	clock_rate = clk_get_rate(clk);
+
+	/* clk_value of atleast 21MHz required
+ 	 * Clock verified on BeagleBone to be 24MHz */
+
+
 	clk_value = clock_rate / ADC_CLK;
 	if (clk_value < 7) {
 		dev_err(&pdev->dev, "clock input less than min clock requirement\n");
 		goto err_fail;
 	}
+
 	/* TSCADC_CLKDIV needs to be configured to the value minus 1 */
 	clk_value = clk_value - 1;
 	tscadc_writel(ts_dev, TSCADC_REG_CLKDIV, clk_value);
@@ -458,57 +627,59 @@ static	int __devinit tscadc_probe(struct platform_device *pdev)
 	ts_dev->wires = pdata->wires;
 	ts_dev->analog_input = pdata->analog_input;
 	ts_dev->x_plate_resistance = pdata->x_plate_resistance;
+	ts_dev->mode = pdata->mode;
 
-	/* Set the control register bits */
+	/* Set the control register bits - 12.5.44 TRM */
 	ctrl = TSCADC_CNTRLREG_STEPCONFIGWRT |
-			TSCADC_CNTRLREG_TSCENB |
-			TSCADC_CNTRLREG_STEPID;
-	switch (ts_dev->wires) {
-	case 4:
-		ctrl |= TSCADC_CNTRLREG_4WIRE;
-		break;
-	case 5:
-		ctrl |= TSCADC_CNTRLREG_5WIRE;
-		break;
-	case 8:
-		ctrl |= TSCADC_CNTRLREG_8WIRE;
-		break;
+				TSCADC_CNTRLREG_STEPID;
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		ctrl |= TSCADC_CNTRLREG_TSCENB;
+		switch (ts_dev->wires) {
+			case 4:
+				ctrl |= TSCADC_CNTRLREG_4WIRE;
+				break;
+			case 5:
+				ctrl |= TSCADC_CNTRLREG_5WIRE;
+				break;
+			case 8:
+				ctrl |= TSCADC_CNTRLREG_8WIRE;
+				break;
+		}
 	}
 	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
 
-	/* Set register bits for Idel Config Mode */
-	tsc_idle_config(ts_dev);
-
-	/* IRQ Enable */
-	irqenable = TSCADC_IRQENB_FIFO1THRES;
+	/* Touch screen / ADC configuration */
+	if(pdata->mode == TI_TSCADC_TSCMODE) {
+		tsc_idle_config(ts_dev);
+		tsc_step_config(ts_dev);
+		tscadc_writel(ts_dev, TSCADC_REG_FIFO1THR, 6);
+		irqenable = TSCADC_IRQENB_FIFO1THRES;
+		/* Touch screen also needs an input_dev */
+		input_dev->name = "ti-tsc-adcc";
+		input_dev->dev.parent = &pdev->dev;
+		input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+		input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+		input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
+		input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
+		/* register to the input system */
+		err = input_register_device(input_dev);
+		if (err)
+			goto err_fail;
+	}
+	else {
+		tscadc_writel(ts_dev, TSCADC_REG_FIFO0THR, 0);
+		irqenable = 0; // TSCADC_IRQENB_FIFO0THRES;
+	}
 	tscadc_writel(ts_dev, TSCADC_REG_IRQENABLE, irqenable);
 
-	tsc_step_config(ts_dev);
-
-	tscadc_writel(ts_dev, TSCADC_REG_FIFO1THR, 6);
-
 	ctrl |= TSCADC_CNTRLREG_TSCSSENB;
-	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);
-
-	input_dev->name = "ti-tsc-adcc";
-	input_dev->dev.parent = &pdev->dev;
-
-	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-
-	input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
-	input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
-	input_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);
-
-	/* register to the input system */
-	err = input_register_device(input_dev);
-	if (err)
-		goto err_fail;
+	tscadc_writel(ts_dev, TSCADC_REG_CTRL, ctrl);	/* Turn on TSC_ADC */
 
 	platform_set_drvdata(pdev, ts_dev);
 	return 0;
 
 err_fail:
+	printk(KERN_ERR "Fatal error, shutting down TSC_ADC\n");
 	clk_disable(ts_dev->tsc_ick);
 	clk_put(ts_dev->tsc_ick);
 err_free_irq:
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index 703013c..554237f 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -1562,6 +1562,9 @@ static void set_data_timeout(struct omap_hsmmc_host *host,
 			dto = 14;
 	}
 
+	/* Set dto to max value of 14 to avoid SD Card timeouts */
+	dto = 14;
+
 	reg &= ~DTO_MASK;
 	reg |= dto << DTO_SHIFT;
 	OMAP_HSMMC_WRITE(host->base, SYSCTL, reg);
diff --git a/include/linux/input/ti_tscadc.h b/include/linux/input/ti_tscadc.h
index 2c547bb..fc239c6 100644
--- a/include/linux/input/ti_tscadc.h
+++ b/include/linux/input/ti_tscadc.h
@@ -13,9 +13,14 @@
  *			0.
  * @x_plate_resistance:	X plate resistance.
  */
+#include <linux/device.h>
+
+#define TI_TSCADC_TSCMODE 0
+#define TI_TSCADC_GENMODE 1
 
 struct tsc_data {
 	int wires;
 	int analog_input;
 	int x_plate_resistance;
+	int mode;
 };
-- 
1.7.4.1

