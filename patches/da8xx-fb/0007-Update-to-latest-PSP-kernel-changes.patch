From 97ea503177680e47c0c0fdcb9bbe8fe3a26276ff Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Mon, 17 Dec 2012 12:02:58 +0200
Subject: [PATCH 7/7] Update to latest PSP kernel changes

Fixes palette bug & vsync callbacks used by SGX

Signed-off-by: Pantelis Antoniou <panto@antoniou-consulting.com>
---
 drivers/video/da8xx-fb.c |  147 +++++++++++++++++++++++++++++++---------------
 include/video/da8xx-fb.h |    4 ++
 2 files changed, 105 insertions(+), 46 deletions(-)

diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 244e4bf..08348bd 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -163,6 +163,7 @@ struct da8xx_fb_par {
 	unsigned int		dma_end;
 	struct clk *lcdc_clk;
 	int irq;
+	u32 pseudo_palette[256];
 	unsigned int palette_sz;
 	unsigned int pxl_clk;
 	int blank;
@@ -181,7 +182,6 @@ struct da8xx_fb_par {
 	unsigned int		lcd_fck_rate;
 #endif
 	void (*panel_power_ctrl)(int);
-	u32 pseudo_palette[16];
 };
 
 /* Variable Screen Information */
@@ -213,6 +213,9 @@ static struct fb_fix_screeninfo da8xx_fb_fix = {
 	.accel = FB_ACCEL_NONE
 };
 
+static vsync_callback_t vsync_cb_handler;
+static void *vsync_cb_arg;
+
 static struct fb_videomode known_lcd_panels[] = {
 	/* Sharp LCD035Q3DG01 */
 	[0] = {
@@ -376,7 +379,7 @@ static void lcd_blit(int load_mode, struct da8xx_fb_par *par)
 			reg_int = lcdc_read(LCD_INT_ENABLE_SET_REG) |
 				LCD_V2_END_OF_FRAME0_INT_ENA |
 				LCD_V2_END_OF_FRAME1_INT_ENA |
-				LCD_FRAME_DONE;
+				LCD_V2_UNDERFLOW_INT_ENA | LCD_SYNC_LOST | LCD_FRAME_DONE;
 			lcdc_write(reg_int, LCD_INT_ENABLE_SET_REG);
 		}
 		reg_dma |= LCD_DUAL_FRAME_BUFFER_ENABLE;
@@ -553,9 +556,6 @@ static int lcd_cfg_frame_buffer(struct da8xx_fb_par *par, u32 width, u32 height,
 {
 	u32 reg;
 
-	if (bpp > 16 && lcd_revision == LCD_VERSION_1)
-		return -EINVAL;
-
 	/* Set the Panel Width */
 	/* Pixels per line = (PPL + 1)*16 */
 	if (lcd_revision == LCD_VERSION_1) {
@@ -600,18 +600,22 @@ static int lcd_cfg_frame_buffer(struct da8xx_fb_par *par, u32 width, u32 height,
 	if (raster_order)
 		reg |= LCD_RASTER_ORDER;
 
-	par->palette_sz = 16 * 2;
+	if (bpp == 24)
+		reg |= (LCD_TFT_MODE | LCD_V2_TFT_24BPP_MODE);
+	else if (bpp == 32)
+		reg |= (LCD_TFT_MODE | LCD_V2_TFT_24BPP_MODE
+				| LCD_V2_TFT_24BPP_UNPACK);
+
+	lcdc_write(reg, LCD_RASTER_CTRL_REG);
 
 	switch (bpp) {
 	case 1:
 	case 2:
 	case 4:
 	case 16:
-		break;
 	case 24:
-		reg |= LCD_V2_TFT_24BPP_MODE;
 	case 32:
-		reg |= LCD_V2_TFT_24BPP_UNPACK;
+		par->palette_sz = 16 * 2;
 		break;
 
 	case 8:
@@ -622,12 +626,9 @@ static int lcd_cfg_frame_buffer(struct da8xx_fb_par *par, u32 width, u32 height,
 		return -EINVAL;
 	}
 
-	lcdc_write(reg, LCD_RASTER_CTRL_REG);
-
 	return 0;
 }
 
-#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
 static int fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 			      unsigned blue, unsigned transp,
 			      struct fb_info *info)
@@ -648,14 +649,57 @@ static int fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 
 	switch (info->fix.visual) {
 	case FB_VISUAL_TRUECOLOR:
-		red = CNVT_TOHW(red, info->var.red.length);
-		green = CNVT_TOHW(green, info->var.green.length);
-		blue = CNVT_TOHW(blue, info->var.blue.length);
+		if (info->var.bits_per_pixel == 8) {
+			red >>= 4;
+			green >>= 8;
+			blue >>= 12;
+
+			pal = (red & 0x0f00);
+			pal |= (green & 0x00f0);
+			pal |= (blue & 0x000f);
+
+			if (palette[regno] != pal) {
+				update_hw = 1;
+				palette[regno] = pal;
+			}
+
+		} else {
+			if (info->var.bits_per_pixel == 16 && regno < 16) {
+				red >>= (16 - info->var.red.length);
+				red <<= info->var.red.offset;
+
+				green >>= (16 - info->var.green.length);
+				green <<= info->var.green.offset;
+
+				blue >>= (16 - info->var.blue.length);
+				blue <<= info->var.blue.offset;
+
+			} else if ((info->var.bits_per_pixel == 32 &&
+						regno < 32) ||
+			    (info->var.bits_per_pixel == 24 &&
+						regno < 24)) {
+				red >>= (24 - info->var.red.length);
+				red <<= info->var.red.offset;
+
+				green >>= (24 - info->var.green.length);
+				green <<= info->var.green.offset;
+
+				blue >>= (24 - info->var.blue.length);
+				blue <<= info->var.blue.offset;
+			}
+			par->pseudo_palette[regno] = red | green | blue;
+
+			if (palette[0] != 0x4000) {
+				update_hw = 1;
+				palette[0] = 0x4000;
+			}
+		}
+
 		break;
 	case FB_VISUAL_PSEUDOCOLOR:
 		switch (info->var.bits_per_pixel) {
 		case 4:
-			if (regno > 15)
+			if (regno > 16)
 				return -EINVAL;
 
 			if (info->var.grayscale) {
@@ -692,32 +736,6 @@ static int fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 		break;
 	}
 
-	/* Truecolor has hardware independent palette */
-	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
-		u32 v;
-
-		if (regno > 15)
-			return -EINVAL;
-
-		v = (red << info->var.red.offset) |
-			(green << info->var.green.offset) |
-			(blue << info->var.blue.offset);
-
-		switch (info->var.bits_per_pixel) {
-		case 16:
-			((u16 *) (info->pseudo_palette))[regno] = v;
-			break;
-		case 24:
-		case 32:
-			((u32 *) (info->pseudo_palette))[regno] = v;
-			break;
-		}
-		if (palette[0] != 0x4000) {
-			update_hw = 1;
-			palette[0] = 0x4000;
-		}
-	}
-
 	/* Update the palette in the h/w as needed. */
 	if (update_hw)
 		lcd_blit(LOAD_PALETTE, par);
@@ -811,6 +829,32 @@ static int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,
 	return 0;
 }
 
+int register_vsync_cb(vsync_callback_t handler, void *arg, int idx)
+{
+	if ((vsync_cb_handler == NULL) && (vsync_cb_arg == NULL)) {
+		vsync_cb_handler = handler;
+		vsync_cb_arg = arg;
+	} else {
+		return -EEXIST;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(register_vsync_cb);
+
+int unregister_vsync_cb(vsync_callback_t handler, void *arg, int idx)
+{
+	if ((vsync_cb_handler == handler) && (vsync_cb_arg == arg)) {
+		vsync_cb_handler = NULL;
+		vsync_cb_arg = NULL;
+	} else {
+		return -ENXIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(unregister_vsync_cb);
+
 /* IRQ handler for version 2 of LCDC */
 static irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)
 {
@@ -848,6 +892,8 @@ static irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)
 				   LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);
 			par->vsync_flag = 1;
 			wake_up_interruptible(&par->vsync_wait);
+			if (vsync_cb_handler)
+				vsync_cb_handler(vsync_cb_arg);
 		}
 
 		if (stat & LCD_END_OF_FRAME1) {
@@ -858,12 +904,14 @@ static irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)
 				   LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG);
 			par->vsync_flag = 1;
 			wake_up_interruptible(&par->vsync_wait);
+			if (vsync_cb_handler)
+				vsync_cb_handler(vsync_cb_arg);
 		}
 
 		/* Set only when controller is disabled and at the end of
 		 * active frame
 		 */
-		if (stat & BIT(0)) {
+		if (stat & LCD_FRAME_DONE) {
 			frame_done_flag = 1;
 			wake_up_interruptible(&frame_done_wq);
 		}
@@ -882,8 +930,10 @@ static irqreturn_t lcdc_irq_handler_rev01(int irq, void *arg)
 
 	if ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {
 		lcd_disable_raster(false);
+		clk_disable(par->lcdc_clk);
 		lcdc_write(stat, LCD_STAT_REG);
 		lcd_enable_raster();
+		clk_enable(par->lcdc_clk);
 	} else if (stat & LCD_PL_LOAD_DONE) {
 		/*
 		 * Must disable raster before changing state of any control bit.
@@ -937,9 +987,6 @@ static int fb_check_var(struct fb_var_screeninfo *var,
 	int bpp = var->bits_per_pixel >> 3;
 	unsigned long line_size = var->xres_virtual * bpp;
 
-	if (var->bits_per_pixel > 16 && lcd_revision == LCD_VERSION_1)
-		return -EINVAL;
-
 	switch (var->bits_per_pixel) {
 	case 1:
 	case 8:
@@ -1122,6 +1169,14 @@ static int fb_wait_for_vsync(struct fb_info *info)
 	if (ret == 0)
 		return -ETIMEDOUT;
 
+	if (par->panel_power_ctrl) {
+		/* Switch off panel power and backlight */
+		par->panel_power_ctrl(0);
+
+		/* Switch on panel power and backlight */
+		par->panel_power_ctrl(1);
+	}
+
 	return 0;
 }
 
diff --git a/include/video/da8xx-fb.h b/include/video/da8xx-fb.h
index 62b1535..6969166 100644
--- a/include/video/da8xx-fb.h
+++ b/include/video/da8xx-fb.h
@@ -86,5 +86,9 @@ struct lcd_sync_arg {
 /* Proprietary FB_SYNC_ flags */
 #define FB_SYNC_CLK_INVERT 0x40000000
 
+typedef void (*vsync_callback_t)(void *arg);
+int register_vsync_cb(vsync_callback_t handler, void *arg, int idx);
+int unregister_vsync_cb(vsync_callback_t handler, void *arg, int idx);
+
 #endif  /* ifndef DA8XX_FB_H */
 
-- 
1.7.10.4

