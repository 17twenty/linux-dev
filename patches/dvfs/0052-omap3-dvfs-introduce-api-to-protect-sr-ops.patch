From 110b3820b0deb2b803f389c8fde4294bc458686a Mon Sep 17 00:00:00 2001
From: Nishanth Menon <nm@ti.com>
Date: Fri, 18 Feb 2011 16:23:31 +0530
Subject: [PATCH 52/53] omap3+: dvfs: introduce api to protect sr ops

When enabling or disabling SR, there is a potential race
with DVFS transitions which may be ongoing in parallel.
introduce dvfs_pause and unpause to allow for pausing the
dvfs operations untill we are done with enabling/disabling
SR

Signed-off-by: Nishanth Menon <nm@ti.com>
---
 arch/arm/mach-omap2/dvfs.c             |   50 ++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/smartreflex.c      |   12 +++++++
 arch/arm/plat-omap/include/plat/dvfs.h |   10 ++++++
 3 files changed, 72 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/dvfs.c b/arch/arm/mach-omap2/dvfs.c
index a00ab95..302d654 100644
--- a/arch/arm/mach-omap2/dvfs.c
+++ b/arch/arm/mach-omap2/dvfs.c
@@ -719,6 +719,56 @@ int omap_device_scale(struct device *req_dev, struct device *target_dev,
 EXPORT_SYMBOL(omap_device_scale);
 
 /**
+ * omap_dvfs_pause() - Pause the dvfs transition for this domain
+ * @voltdom: voltage domain to pause
+ * @trylock: should we return if we dvfs already in transition
+ *
+ * To ensure that the system accesses to internal registers of OMAP
+ * modules are made safe, we need to ensure exclusivity of access
+ * these module drivers request pause of the domain transition while
+ * they finish off their work. The users should ensure sanity
+ * between usual dvfs paths Vs usage of these APIs to prevent deadlocks
+ *
+ * Returns 0 if dvfs has been paused for the domain, else returns err val
+ */
+int omap_dvfs_pause(struct voltagedomain *voltdm, bool trylock)
+{
+	struct omap_vdd_dvfs_info *dvfs_info = get_dvfs_info(voltdm);
+
+	if (IS_ERR_OR_NULL(dvfs_info)) {
+		pr_err("%s: failed to pull dvfs info\n", __func__);
+		return PTR_ERR(dvfs_info);
+	}
+
+	if (trylock)
+		return !mutex_trylock(&dvfs_info->scaling_mutex);
+	else
+		mutex_lock(&dvfs_info->scaling_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(omap_dvfs_pause);
+
+/**
+ * omap_dvfs_unpause() - Free up the dvfs transitions for this domain
+ * @voltdom: voltage domain to unpause
+ *
+ * In the cases where omap_dvfs_pause operations are called, unpause
+ * is used to free up the sequences
+ */
+int omap_dvfs_unpause(struct voltagedomain *voltdm)
+{
+	struct omap_vdd_dvfs_info *dvfs_info = get_dvfs_info(voltdm);
+	if (IS_ERR_OR_NULL(dvfs_info)) {
+		pr_err("%s: failed to pull dvfs info\n", __func__);
+		return PTR_ERR(dvfs_info);
+	}
+
+	mutex_unlock(&dvfs_info->scaling_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(omap_dvfs_unpause);
+
+/**
  * omap_dvfs_init() - Initialize omap dvfs layer
  *
  * Initalizes omap dvfs layer. It basically allocates memory for
diff --git a/arch/arm/mach-omap2/smartreflex.c b/arch/arm/mach-omap2/smartreflex.c
index ddd78ce..6ffc1a0 100644
--- a/arch/arm/mach-omap2/smartreflex.c
+++ b/arch/arm/mach-omap2/smartreflex.c
@@ -27,6 +27,7 @@
 
 #include <plat/common.h>
 #include <plat/smartreflex.h>
+#include <plat/dvfs.h>
 
 #include "pm.h"
 
@@ -940,6 +941,7 @@ static int omap_sr_autocomp_show(void *data, u64 *val)
 static int omap_sr_autocomp_store(void *data, u64 val)
 {
 	struct omap_sr *sr_info = (struct omap_sr *) data;
+	int r;
 
 	if (!sr_info) {
 		pr_warning("%s: omap_sr struct not found\n", __func__);
@@ -954,10 +956,20 @@ static int omap_sr_autocomp_store(void *data, u64 val)
 
 	/* control enable/disable only if there is a delta in value */
 	if (sr_info->autocomp_active ^ val) {
+		r = omap_dvfs_pause(sr_info->voltdm, false);
+		if (r) {
+			pr_warning("%s: unable to secure dvfs transition:%d\n",
+					__func__, r);
+			return r;
+		}
 		if (!val)
 			sr_stop_vddautocomp(sr_info);
 		else
 			sr_start_vddautocomp(sr_info);
+		r = omap_dvfs_unpause(sr_info->voltdm);
+		if (r)
+			pr_err("%s: unable to release dvfs transition:%d\n",
+					__func__, r);
 	}
 
 	return 0;
diff --git a/arch/arm/plat-omap/include/plat/dvfs.h b/arch/arm/plat-omap/include/plat/dvfs.h
index 1be2b9d..bee42ca 100644
--- a/arch/arm/plat-omap/include/plat/dvfs.h
+++ b/arch/arm/plat-omap/include/plat/dvfs.h
@@ -19,6 +19,8 @@
 int omap_dvfs_register_device(struct voltagedomain *voltdm, struct device *dev);
 int omap_device_scale(struct device *req_dev, struct device *dev,
 			unsigned long rate);
+int omap_dvfs_pause(struct voltagedomain *voltdm, bool trylock);
+int omap_dvfs_unpause(struct voltagedomain *voltdm);
 #else
 static inline int omap_dvfs_register_device(struct voltagedomain *voltdm,
 		struct device *dev)
@@ -30,5 +32,13 @@ static inline int omap_device_scale(struct device *req_dev, struct devices
 {
 	return -EINVAL;
 }
+static int omap_dfvs_pause(struct voltagedomain *voltdm, bool trylock)
+{
+	return 0;
+}
+static int omap_dfvs_unpause(struct voltagedomain *voltdm)
+{
+	return 0;
+}
 #endif
 #endif
-- 
1.7.1

